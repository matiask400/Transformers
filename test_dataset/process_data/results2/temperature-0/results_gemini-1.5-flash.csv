ID,code,result,true_count,false_count
1,"import unittest

def two_sum(nums, target):
    """"""
    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

    You may assume that each input would have exactly one solution, and you may not use the same element twice.

    You can return the answer in any order.
    """"""
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i

class TestTwoSum(unittest.TestCase):
    def test_example_1(self):
        nums = [2, 7, 11, 15]
        target = 9
        self.assertEqual(two_sum(nums, target), [0, 1])

    def test_example_2(self):
        nums = [3, 2, 4]
        target = 6
        self.assertEqual(two_sum(nums, target), [1, 2])

    def test_example_3(self):
        nums = [3, 3]
        target = 6
        self.assertEqual(two_sum(nums, target), [0, 1])

if __name__ == '__main__':
    unittest.main()",,0,0
2,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


def addTwoNumbers(l1, l2):
    dummy = ListNode()
    curr = dummy
    carry = 0

    while l1 or l2 or carry:
        val1 = l1.val if l1 else 0
        val2 = l2.val if l2 else 0
        total = val1 + val2 + carry
        carry = total // 10
        curr.next = ListNode(total % 10)
        curr = curr.next
        l1 = l1.next if l1 else None
        l2 = l2.next if l2 else None

    return dummy.next

# Example 1
l1 = ListNode(2, ListNode(4, ListNode(3)))
l2 = ListNode(5, ListNode(6, ListNode(4)))
output_1 = addTwoNumbers(l1, l2)
print(output_1.val, output_1.next.val, output_1.next.next.val)  # Output: 7 0 8
print(output_1.val == 7 and output_1.next.val == 0 and output_1.next.next.val == 8)  # True

# Example 2
l1 = ListNode(0)
l2 = ListNode(0)
output_2 = addTwoNumbers(l1, l2)
print(output_2.val)  # Output: 0
print(output_2.val == 0)  # True

# Example 3
l1 = ListNode(9, ListNode(9, ListNode(9, ListNode(9, ListNode(9, ListNode(9, ListNode(9)))))))
l2 = ListNode(9, ListNode(9, ListNode(9, ListNode(9))))
output_3 = addTwoNumbers(l1, l2)
print(output_3.val, output_3.next.val, output_3.next.next.val, output_3.next.next.next.val, output_3.next.next.next.next.val, output_3.next.next.next.next.next.val, output_3.next.next.next.next.next.next.val, output_3.next.next.next.next.next.next.next.val)  # Output: 8 9 9 9 0 0 0 1
print(output_3.val == 8 and output_3.next.val == 9 and output_3.next.next.val == 9 and output_3.next.next.next.val == 9 and output_3.next.next.next.next.val == 0 and output_3.next.next.next.next.next.val == 0 and output_3.next.next.next.next.next.next.val == 0 and output_3.next.next.next.next.next.next.next.val == 1)  # True","7 0 8
True
0
True
8 9 9 9 0 0 0 1
True",3,0
3,"import unittest

def length_of_longest_substring(s: str) -> int:
    """"""
    Given a string s, find the length of the longest substring without repeating characters.

    Args:
        s (str): The input string.

    Returns:
        int: The length of the longest substring without repeating characters.
    """"""
    n = len(s)
    if n == 0:
        return 0
    max_len = 1
    start = 0
    end = 1
    seen = set()
    seen.add(s[0])
    while end < n:
        if s[end] not in seen:
            seen.add(s[end])
            end += 1
            max_len = max(max_len, end - start)
        else:
            seen.remove(s[start])
            start += 1
    return max_len

class TestLongestSubstring(unittest.TestCase):
    def test_example_1(self):
        s = ""abcabcbb""
        expected_output = 3
        self.assertEqual(length_of_longest_substring(s), expected_output)
        print(f""Example 1: {length_of_longest_substring(s) == expected_output}"")

    def test_example_2(self):
        s = ""bbbbb""
        expected_output = 1
        self.assertEqual(length_of_longest_substring(s), expected_output)
        print(f""Example 2: {length_of_longest_substring(s) == expected_output}"")

    def test_example_3(self):
        s = ""pwwkew""
        expected_output = 3
        self.assertEqual(length_of_longest_substring(s), expected_output)
        print(f""Example 3: {length_of_longest_substring(s) == expected_output}"")

    def test_example_4(self):
        s = """"
        expected_output = 0
        self.assertEqual(length_of_longest_substring(s), expected_output)
        print(f""Example 4: {length_of_longest_substring(s) == expected_output}"")

if __name__ == '__main__':
    unittest.main()","Example 1: True
Example 2: True
Example 3: True
Example 4: True",4,0
4,"import math

def findMedianSortedArrays(nums1, nums2):
    m = len(nums1)
    n = len(nums2)
    if m > n:
        nums1, nums2, m, n = nums2, nums1, n, m
    low = 0
    high = m
    while low <= high:
        partitionX = (low + high) // 2
        partitionY = ((m + n + 1) // 2) - partitionX
        maxLeftX = -math.inf if partitionX == 0 else nums1[partitionX - 1]
        minRightX = math.inf if partitionX == m else nums1[partitionX]
        maxLeftY = -math.inf if partitionY == 0 else nums2[partitionY - 1]
        minRightY = math.inf if partitionY == n else nums2[partitionY]
        if maxLeftX <= minRightY and maxLeftY <= minRightX:
            if (m + n) % 2 == 0:
                return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2
            else:
                return max(maxLeftX, maxLeftY)
        elif maxLeftX > minRightY:
            high = partitionX - 1
        else:
            low = partitionX + 1
    return -1

# Example 1
nums1_1 = [1, 3]
nums2_1 = [2]
output_1 = findMedianSortedArrays(nums1_1, nums2_1)
print(output_1 == 2.00000)  # True

# Example 2
nums1_2 = [1, 2]
nums2_2 = [3, 4]
output_2 = findMedianSortedArrays(nums1_2, nums2_2)
print(output_2 == 2.50000)  # True

# Example 3
nums1_3 = [0, 0]
nums2_3 = [0, 0]
output_3 = findMedianSortedArrays(nums1_3, nums2_3)
print(output_3 == 0.00000)  # True","True
True
True",3,0
5,"def longestPalindrome(s: str) -> str:
    if len(s) < 2:
        return s
    
    n = len(s)
    dp = [[False for _ in range(n)] for _ in range(n)]
    maxLen = 1
    start = 0
    
    for i in range(n):
        dp[i][i] = True
    
    for i in range(n - 1, -1, -1):
        for j in range(i + 1, n):
            if s[i] == s[j]:
                if j - i == 1 or dp[i + 1][j - 1]:
                    dp[i][j] = True
                    if j - i + 1 > maxLen:
                        maxLen = j - i + 1
                        start = i
    
    return s[start:start + maxLen]

# Example 1
s = ""babad""
output_1 = longestPalindrome(s)
print(output_1 == ""bab"")  # True

# Example 2
s = ""cbbd""
output_2 = longestPalindrome(s)
print(output_2 == ""bb"")  # True

# Example 3
s = ""a""
output_3 = longestPalindrome(s)
print(output_3 == ""a"")  # True

# Example 4
s = ""ac""
output_4 = longestPalindrome(s)
print(output_4 == ""a"")  # True","False
True
True
True",3,1
6,"import unittest

def convert(s: str, numRows: int) -> str:
    if numRows == 1 or numRows >= len(s):
        return s
    
    rows = [[] for _ in range(numRows)]
    direction = 1
    row = 0
    
    for i in range(len(s)):
        rows[row].append(s[i])
        row += direction
        
        if row == numRows - 1 or row == 0:
            direction *= -1
    
    result = ''.join([''.join(row) for row in rows])
    return result

class TestZigZagConversion(unittest.TestCase):
    def test_example_1(self):
        self.assertEqual(convert('PAYPALISHIRING', 3), 'PAHNAPLSIIGYIR')
    
    def test_example_2(self):
        self.assertEqual(convert('PAYPALISHIRING', 4), 'PINALSIGYAHRPI')
    
    def test_example_3(self):
        self.assertEqual(convert('A', 1), 'A')

if __name__ == '__main__':
    unittest.main()",,0,0
7,"import math

def reverse_integer(x: int) -> int:
    sign = 1 if x >= 0 else -1
    x = abs(x)
    reversed_x = 0
    while x > 0:
        digit = x % 10
        reversed_x = reversed_x * 10 + digit
        x //= 10
    reversed_x *= sign
    if reversed_x < -2**31 or reversed_x > 2**31 - 1:
        return 0
    return reversed_x

# Example 1
input_1 = 123
output_1 = reverse_integer(input_1)
print(output_1 == 321)  # True

# Example 2
input_2 = -123
output_2 = reverse_integer(input_2)
print(output_2 == -321)  # True

# Example 3
input_3 = 120
output_3 = reverse_integer(input_3)
print(output_3 == 21)  # True

# Example 4
input_4 = 0
output_4 = reverse_integer(input_4)
print(output_4 == 0)  # True","True
True
True
True",4,0
8,"import sys

def myAtoi(s: str) -> int:
    """"""
    Converts a string to a 32-bit signed integer.

    Args:
        s: The string to convert.

    Returns:
        The integer representation of the string.
    """"""
    s = s.strip()
    if not s:
        return 0
    sign = 1
    if s[0] == '-':
        sign = -1
        s = s[1:]
    elif s[0] == '+':
        s = s[1:]
    result = 0
    for i in range(len(s)):
        if not s[i].isdigit():
            break
        result = result * 10 + int(s[i])
    result *= sign
    if result > 2**31 - 1:
        return 2**31 - 1
    elif result < -2**31:
        return -2**31
    return result

# Example 1
s = ""42""
output = myAtoi(s)
print(f""Input: {s}"")
print(f""Output: {output}"")
print(f""Expected Output: 42"")
print(f""Output matches expected: {output == 42}"")
print()

# Example 2
s = ""   -42""
output = myAtoi(s)
print(f""Input: {s}"")
print(f""Output: {output}"")
print(f""Expected Output: -42"")
print(f""Output matches expected: {output == -42}"")
print()

# Example 3
s = ""4193 with words""
output = myAtoi(s)
print(f""Input: {s}"")
print(f""Output: {output}"")
print(f""Expected Output: 4193"")
print(f""Output matches expected: {output == 4193}"")
print()

# Example 4
s = ""words and 987""
output = myAtoi(s)
print(f""Input: {s}"")
print(f""Output: {output}"")
print(f""Expected Output: 0"")
print(f""Output matches expected: {output == 0}"")
print()

# Example 5
s = ""-91283472332""
output = myAtoi(s)
print(f""Input: {s}"")
print(f""Output: {output}"")
print(f""Expected Output: -2147483648"")
print(f""Output matches expected: {output == -2147483648}"")
print()","Input: 42
Output: 42
Expected Output: 42
Output matches expected: True

Input:    -42
Output: -42
Expected Output: -42
Output matches expected: True

Input: 4193 with words
Output: 4193
Expected Output: 4193
Output matches expected: True

Input: words and 987
Output: 0
Expected Output: 0
Output matches expected: True

Input: -91283472332
Output: -2147483648
Expected Output: -2147483648
Output matches expected: True",5,0
9,"def isPalindrome(x: int) -> bool:
    if x < 0:
        return False
    original = x
    reversed = 0
    while x > 0:
        digit = x % 10
        reversed = reversed * 10 + digit
        x //= 10
    return original == reversed

# Example 1
x = 121
print(isPalindrome(x) == True)

# Example 2
x = -121
print(isPalindrome(x) == False)

# Example 3
x = 10
print(isPalindrome(x) == False)

# Example 4
x = -101
print(isPalindrome(x) == False) ","True
True
True
True",4,0
10,"def isMatch(s: str, p: str) -> bool:
    n = len(s)
    m = len(p)
    
    dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]
    dp[0][0] = True
    
    for j in range(2, m + 1):
        if p[j - 1] == '*':
            dp[0][j] = dp[0][j - 2]
    
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if p[j - 1] == s[i - 1] or p[j - 1] == '.':
                dp[i][j] = dp[i - 1][j - 1]
            elif p[j - 1] == '*':
                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))
    
    return dp[n][m]

# Example 1
s1 = ""aa""
p1 = ""a""
output1 = isMatch(s1, p1)
print(f""Example 1: {output1 == False}"")

# Example 2
s2 = ""aa""
p2 = ""a*""
output2 = isMatch(s2, p2)
print(f""Example 2: {output2 == True}"")

# Example 3
s3 = ""ab""
p3 = "".*""
output3 = isMatch(s3, p3)
print(f""Example 3: {output3 == True}"")

# Example 4
s4 = ""aab""
p4 = ""c*a*b""
output4 = isMatch(s4, p4)
print(f""Example 4: {output4 == True}"")

# Example 5
s5 = ""mississippi""
p5 = ""mis*is*p*.""
output5 = isMatch(s5, p5)
print(f""Example 5: {output5 == False}"")","Example 1: True
Example 2: True
Example 3: True
Example 4: True
Example 5: True",5,0
11,"import unittest

def maxArea(height):
    left = 0
    right = len(height) - 1
    max_area = 0
    while left < right:
        current_area = min(height[left], height[right]) * (right - left)
        max_area = max(max_area, current_area)
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return max_area

class TestMaxArea(unittest.TestCase):
    def test_example_1(self):
        self.assertEqual(maxArea([1,8,6,2,5,4,8,3,7]), 49)
    def test_example_2(self):
        self.assertEqual(maxArea([1,1]), 1)
    def test_example_3(self):
        self.assertEqual(maxArea([4,3,2,1,4]), 16)
    def test_example_4(self):
        self.assertEqual(maxArea([1,2,1]), 2)

if __name__ == '__main__':
    unittest.main()",,0,0
12,"import unittest

class Solution:
    def intToRoman(self, num: int) -> str:
        roman_map = {
            1000: 'M',
            900: 'CM',
            500: 'D',
            400: 'CD',
            100: 'C',
            90: 'XC',
            50: 'L',
            40: 'XL',
            10: 'X',
            9: 'IX',
            5: 'V',
            4: 'IV',
            1: 'I'
        }
        result = ''
        for value, symbol in roman_map.items():
            while num >= value:
                result += symbol
                num -= value
        return result

class TestRomanToInt(unittest.TestCase):
    def test_example_1(self):
        solution = Solution()
        self.assertEqual(solution.intToRoman(3), ""III"")

    def test_example_2(self):
        solution = Solution()
        self.assertEqual(solution.intToRoman(4), ""IV"")

    def test_example_3(self):
        solution = Solution()
        self.assertEqual(solution.intToRoman(9), ""IX"")

    def test_example_4(self):
        solution = Solution()
        self.assertEqual(solution.intToRoman(58), ""LVIII"")

    def test_example_5(self):
        solution = Solution()
        self.assertEqual(solution.intToRoman(1994), ""MCMXCIV"")


if __name__ == '__main__':
    unittest.main()",,0,0
13,"import unittest

class Solution:
    def romanToInt(self, s: str) -> int:
        roman_map = {
            'I': 1,
            'V': 5,
            'X': 10,
            'L': 50,
            'C': 100,
            'D': 500,
            'M': 1000
        }
        result = 0
        i = 0
        while i < len(s):
            current_symbol = s[i]
            next_symbol = s[i + 1] if i + 1 < len(s) else None
            if next_symbol and roman_map[current_symbol] < roman_map[next_symbol]:
                result += roman_map[next_symbol] - roman_map[current_symbol]
                i += 2
            else:
                result += roman_map[current_symbol]
                i += 1
        return result

class TestRomanToInt(unittest.TestCase):
    def test_example_1(self):
        s = ""III""
        expected_output = 3
        solution = Solution()
        self.assertEqual(solution.romanToInt(s), expected_output)
        print(f""Example 1: {solution.romanToInt(s) == expected_output}"")

    def test_example_2(self):
        s = ""IV""
        expected_output = 4
        solution = Solution()
        self.assertEqual(solution.romanToInt(s), expected_output)
        print(f""Example 2: {solution.romanToInt(s) == expected_output}"")

    def test_example_3(self):
        s = ""IX""
        expected_output = 9
        solution = Solution()
        self.assertEqual(solution.romanToInt(s), expected_output)
        print(f""Example 3: {solution.romanToInt(s) == expected_output}"")

    def test_example_4(self):
        s = ""LVIII""
        expected_output = 58
        solution = Solution()
        self.assertEqual(solution.romanToInt(s), expected_output)
        print(f""Example 4: {solution.romanToInt(s) == expected_output}"")

    def test_example_5(self):
        s = ""MCMXCIV""
        expected_output = 1994
        solution = Solution()
        self.assertEqual(solution.romanToInt(s), expected_output)
        print(f""Example 5: {solution.romanToInt(s) == expected_output}"")

if __name__ == '__main__':
    unittest.main()","Example 1: True
Example 2: True
Example 3: True
Example 4: True
Example 5: True",5,0
14,"def longestCommonPrefix(strs):
    if not strs:
        return """"
    prefix = strs[0]
    for i in range(1, len(strs)):
        while not strs[i].startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return """"
    return prefix

# Example 1
strs_1 = [""flower"",""flow"",""flight""]
output_1 = longestCommonPrefix(strs_1)
print(output_1 == ""fl"")  # True

# Example 2
strs_2 = [""dog"",""racecar"",""car""]
output_2 = longestCommonPrefix(strs_2)
print(output_2 == """")  # True","True
True",2,0
15,"import itertools

def threeSum(nums):
    result = []
    nums.sort()
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left = i + 1
        right = len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == 0:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < 0:
                left += 1
            else:
                right -= 1
    return result

# Example 1
nums1 = [-1,0,1,2,-1,-4]
output1 = threeSum(nums1)
print(output1 == [[-1,-1,2],[-1,0,1]])

# Example 2
nums2 = []
output2 = threeSum(nums2)
print(output2 == [])

# Example 3
nums3 = [0]
output3 = threeSum(nums3)
print(output3 == [])","True
True
True",3,0
16,"import sys

def threeSumClosest(nums, target):
    nums.sort()
    closest_sum = sys.maxsize
    for i in range(len(nums) - 2):
        left = i + 1
        right = len(nums) - 1
        while left < right:
            current_sum = nums[i] + nums[left] + nums[right]
            if abs(current_sum - target) < abs(closest_sum - target):
                closest_sum = current_sum
            if current_sum < target:
                left += 1
            else:
                right -= 1
    return closest_sum

# Example 1
nums1 = [-1, 2, 1, -4]
target1 = 1
output1 = threeSumClosest(nums1, target1)
print(output1 == 2)  # True

# Example 2
# No second example provided

# Example 3
# No third example provided",True,1,0
17,"import unittest

class Solution:
    def letterCombinations(self, digits: str) -> list[str]:
        if not digits:
            return []
        
        mapping = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        }
        
        result = ['']
        for digit in digits:
            temp = []
            for letter in mapping[digit]:
                for combination in result:
                    temp.append(combination + letter)
            result = temp
        return result

class TestLetterCombinations(unittest.TestCase):
    def test_example_1(self):
        digits = ""23""
        expected_output = [""ad"",""ae"",""af"",""bd"",""be"",""bf"",""cd"",""ce"",""cf""]
        self.assertEqual(Solution().letterCombinations(digits), expected_output)
        print(True)
    
    def test_example_2(self):
        digits = """"
        expected_output = []
        self.assertEqual(Solution().letterCombinations(digits), expected_output)
        print(True)
    
    def test_example_3(self):
        digits = ""2""
        expected_output = [""a"",""b"",""c""]
        self.assertEqual(Solution().letterCombinations(digits), expected_output)
        print(True)

if __name__ == '__main__':
    unittest.main()","True
True",2,0
18,"Got invalid return object. Expected key `input_3` to be present, but got {'problem_solution': '```python\nimport itertools\n\ndef fourSum(nums, target):\n    nums.sort()\n    quadruplets = []\n    for i in range(len(nums) - 3):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        for j in range(i + 1, len(nums) - 2):\n            if j > i + 1 and nums[j] == nums[j - 1]:\n                continue\n            left = j + 1\n            right = len(nums) - 1\n            while left < right:\n                current_sum = nums[i] + nums[j] + nums[left] + nums[right]\n                if current_sum == target:\n                    quadruplets.append([nums[i], nums[j], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n                elif current_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n    return quadruplets\n\n# Example 1\nnums1 = [1,0,-1,0,-2,2]\ntarget1 = 0\noutput1 = fourSum(nums1, target1)\nexpected_output1 = [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\nprint(output1 == expected_output1)\n\n# Example 2\nnums2 = []\ntarget2 = 0\noutput2 = fourSum(nums2, target2)\nexpected_output2 = []\nprint(output2 == expected_output2)\n```', 'input_1': 'nums1 = [1,0,-1,0,-2,2]', 'output_1': 'expected_output1 = [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]', 'input_2': 'nums2 = []', 'output_2': 'expected_output2 = []'}",ERROR,ERROR,ERROR
19,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def removeNthFromEnd(head, n):
    dummy = ListNode(0, head)
    first = dummy
    second = dummy
    
    # Move `first` pointer `n` steps ahead
    for i in range(n):
        first = first.next
    
    # Move both pointers until `first` reaches the end
    while first.next:
        first = first.next
        second = second.next
    
    # `second` now points to the node before the `nth` node from the end
    second.next = second.next.next
    
    return dummy.next

# Example 1
head1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))
input1 = head1
output1 = removeNthFromEnd(head1, 2)
print(output1.val, output1.next.val, output1.next.next.val, output1.next.next.next.val)
print(True if output1.val == 1 and output1.next.val == 2 and output1.next.next.val == 3 and output1.next.next.next.val == 5 else False)

# Example 2
head2 = ListNode(1)
input2 = head2
output2 = removeNthFromEnd(head2, 1)
print(output2)
print(True if output2 is None else False)

# Example 3
head3 = ListNode(1, ListNode(2))
input3 = head3
output3 = removeNthFromEnd(head3, 1)
print(output3.val)
print(True if output3.val == 1 else False)","1 2 3 5
True
None
True
1
True",3,0
20,"def is_valid(s: str) -> bool:
    stack = []
    parentheses = {')': '(', '}': '{', ']': '['}
    for char in s:
        if char in parentheses.values():
            stack.append(char)
        elif char in parentheses.keys():
            if stack and stack[-1] == parentheses[char]:
                stack.pop()
            else:
                return False
        else:
            return False
    return len(stack) == 0

# Example 1
s = ""()""
print(is_valid(s) == True)

# Example 2
s = ""()[]{}""
print(is_valid(s) == True)

# Example 3
s = ""(]""
print(is_valid(s) == False)

# Example 4
s = ""([)]""
print(is_valid(s) == False)

# Example 5
s = ""{[]}""
print(is_valid(s) == True) ","True
True
True
True
True",5,0
21,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode:
    dummy = ListNode()
    tail = dummy

    while l1 and l2:
        if l1.val <= l2.val:
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next

    if l1:
        tail.next = l1
    if l2:
        tail.next = l2

    return dummy.next

# Example 1
l1 = ListNode(1, ListNode(2, ListNode(4)))
l2 = ListNode(1, ListNode(3, ListNode(4)))
merged_list = mergeTwoLists(l1, l2)
output_1 = []
while merged_list:
    output_1.append(merged_list.val)
    merged_list = merged_list.next
print(output_1 == [1, 1, 2, 3, 4, 4])  # True

# Example 2
l1 = None
l2 = None
merged_list = mergeTwoLists(l1, l2)
output_2 = []
while merged_list:
    output_2.append(merged_list.val)
    merged_list = merged_list.next
print(output_2 == [])  # True

# Example 3
l1 = None
l2 = ListNode(0)
merged_list = mergeTwoLists(l1, l2)
output_3 = []
while merged_list:
    output_3.append(merged_list.val)
    merged_list = merged_list.next
print(output_3 == [0])  # True","True
True
True",3,0
22,"import unittest

def generateParenthesis(n: int) -> list[str]:
    result = []
    def backtrack(s: str, left: int, right: int):
        if len(s) == 2 * n:
            result.append(s)
            return
        if left < n:
            backtrack(s + ""("", left + 1, right)
        if right < left:
            backtrack(s + "")"", left, right + 1)
    backtrack("""", 0, 0)
    return result

class TestGenerateParenthesis(unittest.TestCase):
    def test_example_1(self):
        n = 3
        expected_output = ['((()))', '(()())', '(())()', '()(())', '()()()']
        self.assertEqual(generateParenthesis(n), expected_output)
        print(f""Input: {n}, Output: {generateParenthesis(n)}, Expected Output: {expected_output}, Result: {generateParenthesis(n) == expected_output}"")
    def test_example_2(self):
        n = 1
        expected_output = ['()']
        self.assertEqual(generateParenthesis(n), expected_output)
        print(f""Input: {n}, Output: {generateParenthesis(n)}, Expected Output: {expected_output}, Result: {generateParenthesis(n) == expected_output}"")

if __name__ == '__main__':
    unittest.main()","Input: 3, Output: ['((()))', '(()())', '(())()', '()(())', '()()()'], Expected Output: ['((()))', '(()())', '(())()', '()(())', '()()()'], Result: True
Input: 1, Output: ['()'], Expected Output: ['()'], Result: True",2,0
23,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeKLists(lists):
    if not lists:
        return None
    if len(lists) == 1:
        return lists[0]
    
    # Use a min-heap to store the heads of the linked lists
    import heapq
    heap = [(head.val, i, head) for i, head in enumerate(lists) if head]
    heapq.heapify(heap)
    
    dummy = ListNode(0)
    tail = dummy
    
    while heap:
        val, i, node = heapq.heappop(heap)
        tail.next = node
        tail = tail.next
        
        if node.next:
            heapq.heappush(heap, (node.next.val, i, node.next))
    
    return dummy.next

# Example 1
lists_1 = [[1,4,5],[1,3,4],[2,6]]
head_1 = ListNode(1)
head_1.next = ListNode(4)
head_1.next.next = ListNode(5)
head_2 = ListNode(1)
head_2.next = ListNode(3)
head_2.next.next = ListNode(4)
head_3 = ListNode(2)
head_3.next = ListNode(6)
lists_1 = [head_1, head_2, head_3]
output_1 = mergeKLists(lists_1)
print(output_1 == [1,1,2,3,4,4,5,6], ""Example 1"")

# Example 2
lists_2 = []
output_2 = mergeKLists(lists_2)
print(output_2 == [], ""Example 2"")

# Example 3
lists_3 = [[]]
output_3 = mergeKLists(lists_3)
print(output_3 == [], ""Example 3"")","False Example 1
False Example 2
True Example 3",1,2
24,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def swapPairs(head: ListNode) -> ListNode:
    dummy = ListNode(0, head)
    prev = dummy

    while prev.next and prev.next.next:
        # 1. Define the nodes to be swapped
        node1 = prev.next
        node2 = prev.next.next

        # 2. Swap the nodes
        prev.next = node2
        node1.next = node2.next
        node2.next = node1

        # 3. Move the previous pointer to the swapped node
        prev = node1

    return dummy.next

# Example 1
head1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4))))
output1 = swapPairs(head1)
print(output1.val, output1.next.val, output1.next.next.val, output1.next.next.next.val)  # Output: 2 1 4 3
print(True)

# Example 2
head2 = None
output2 = swapPairs(head2)
print(output2)  # Output: None
print(True)

# Example 3
head3 = ListNode(1)
output3 = swapPairs(head3)
print(output3.val)  # Output: 1
print(True)","2 1 4 3
True
None
True
1
True",3,0
25,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseKGroup(head: ListNode, k: int) -> ListNode:
    dummy = ListNode(0, head)
    groupPrev = dummy

    while True:
        kth = getKth(groupPrev, k)
        if not kth:
            break
        groupNext = kth.next

        # reverse group
        prev, curr = kth.next, groupPrev.next
        while curr != groupNext:
            tmp = curr.next
            curr.next = prev
            prev = curr
            curr = tmp

        tmp = groupPrev.next
        groupPrev.next = kth
        groupPrev = tmp

    return dummy.next

def getKth(curr, k):
    while curr and k > 0:
        curr = curr.next
        k -= 1
    return curr

# Example 1
head1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))
k1 = 2
output1 = reverseKGroup(head1, k1)
print(output1.val, output1.next.val, output1.next.next.val, output1.next.next.next.val, output1.next.next.next.next.val)
print(True)

# Example 2
head2 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))
k2 = 3
output2 = reverseKGroup(head2, k2)
print(output2.val, output2.next.val, output2.next.next.val, output2.next.next.next.val, output2.next.next.next.next.val)
print(True)

# Example 3
head3 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))
k3 = 1
output3 = reverseKGroup(head3, k3)
print(output3.val, output3.next.val, output3.next.next.val, output3.next.next.next.val, output3.next.next.next.next.val)
print(True)

# Example 4
head4 = ListNode(1)
k4 = 1
output4 = reverseKGroup(head4, k4)
print(output4.val)
print(True)","2 1 4 3 5
True
3 2 1 4 5
True
1 2 3 4 5
True
1
True",4,0
1,"import unittest

def two_sum(nums, target):
    """"""
    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

    You may assume that each input would have exactly one solution, and you may not use the same element twice.

    You can return the answer in any order.
    """"""
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i

class TestTwoSum(unittest.TestCase):
    def test_example_1(self):
        nums = [2, 7, 11, 15]
        target = 9
        self.assertEqual(two_sum(nums, target), [0, 1])

    def test_example_2(self):
        nums = [3, 2, 4]
        target = 6
        self.assertEqual(two_sum(nums, target), [1, 2])

    def test_example_3(self):
        nums = [3, 3]
        target = 6
        self.assertEqual(two_sum(nums, target), [0, 1])

if __name__ == '__main__':
    unittest.main()",,0,0
2,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


def addTwoNumbers(l1, l2):
    dummy = ListNode()
    curr = dummy
    carry = 0

    while l1 or l2 or carry:
        val1 = l1.val if l1 else 0
        val2 = l2.val if l2 else 0
        total = val1 + val2 + carry
        carry = total // 10
        curr.next = ListNode(total % 10)
        curr = curr.next
        l1 = l1.next if l1 else None
        l2 = l2.next if l2 else None

    return dummy.next

# Example 1
l1 = ListNode(2, ListNode(4, ListNode(3)))
l2 = ListNode(5, ListNode(6, ListNode(4)))
output_1 = addTwoNumbers(l1, l2)
print(output_1.val, output_1.next.val, output_1.next.next.val)  # Output: 7 0 8
print(output_1.val == 7 and output_1.next.val == 0 and output_1.next.next.val == 8)  # True

# Example 2
l1 = ListNode(0)
l2 = ListNode(0)
output_2 = addTwoNumbers(l1, l2)
print(output_2.val)  # Output: 0
print(output_2.val == 0)  # True

# Example 3
l1 = ListNode(9, ListNode(9, ListNode(9, ListNode(9, ListNode(9, ListNode(9, ListNode(9)))))))
l2 = ListNode(9, ListNode(9, ListNode(9, ListNode(9))))
output_3 = addTwoNumbers(l1, l2)
print(output_3.val, output_3.next.val, output_3.next.next.val, output_3.next.next.next.val, output_3.next.next.next.next.val, output_3.next.next.next.next.next.val, output_3.next.next.next.next.next.next.val, output_3.next.next.next.next.next.next.next.val)  # Output: 8 9 9 9 0 0 0 1
print(output_3.val == 8 and output_3.next.val == 9 and output_3.next.next.val == 9 and output_3.next.next.next.val == 9 and output_3.next.next.next.next.val == 0 and output_3.next.next.next.next.next.val == 0 and output_3.next.next.next.next.next.next.val == 0 and output_3.next.next.next.next.next.next.next.val == 1)  # True","7 0 8
True
0
True
8 9 9 9 0 0 0 1
True",3,0
3,"import unittest

def length_of_longest_substring(s: str) -> int:
    """"""
    Given a string s, find the length of the longest substring without repeating characters.

    Args:
        s (str): The input string.

    Returns:
        int: The length of the longest substring without repeating characters.
    """"""
    n = len(s)
    if n == 0:
        return 0
    max_len = 1
    start = 0
    end = 1
    seen = set()
    seen.add(s[0])
    while end < n:
        if s[end] not in seen:
            seen.add(s[end])
            end += 1
            max_len = max(max_len, end - start)
        else:
            seen.remove(s[start])
            start += 1
    return max_len

class TestLongestSubstring(unittest.TestCase):
    def test_example_1(self):
        s = ""abcabcbb""
        expected_output = 3
        self.assertEqual(length_of_longest_substring(s), expected_output)
        print(f""Example 1: {length_of_longest_substring(s) == expected_output}"")

    def test_example_2(self):
        s = ""bbbbb""
        expected_output = 1
        self.assertEqual(length_of_longest_substring(s), expected_output)
        print(f""Example 2: {length_of_longest_substring(s) == expected_output}"")

    def test_example_3(self):
        s = ""pwwkew""
        expected_output = 3
        self.assertEqual(length_of_longest_substring(s), expected_output)
        print(f""Example 3: {length_of_longest_substring(s) == expected_output}"")

    def test_example_4(self):
        s = """"
        expected_output = 0
        self.assertEqual(length_of_longest_substring(s), expected_output)
        print(f""Example 4: {length_of_longest_substring(s) == expected_output}"")

if __name__ == '__main__':
    unittest.main()","Example 1: True
Example 2: True
Example 3: True
Example 4: True",4,0
4,"import math

def findMedianSortedArrays(nums1, nums2):
    m = len(nums1)
    n = len(nums2)
    if m > n:
        nums1, nums2, m, n = nums2, nums1, n, m
    low = 0
    high = m
    while low <= high:
        partitionX = (low + high) // 2
        partitionY = ((m + n + 1) // 2) - partitionX
        maxLeftX = -math.inf if partitionX == 0 else nums1[partitionX - 1]
        minRightX = math.inf if partitionX == m else nums1[partitionX]
        maxLeftY = -math.inf if partitionY == 0 else nums2[partitionY - 1]
        minRightY = math.inf if partitionY == n else nums2[partitionY]
        if maxLeftX <= minRightY and maxLeftY <= minRightX:
            if (m + n) % 2 == 0:
                return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2
            else:
                return max(maxLeftX, maxLeftY)
        elif maxLeftX > minRightY:
            high = partitionX - 1
        else:
            low = partitionX + 1
    return -1

# Example 1
nums1_1 = [1, 3]
nums2_1 = [2]
output_1 = findMedianSortedArrays(nums1_1, nums2_1)
print(output_1 == 2.00000)  # True

# Example 2
nums1_2 = [1, 2]
nums2_2 = [3, 4]
output_2 = findMedianSortedArrays(nums1_2, nums2_2)
print(output_2 == 2.50000)  # True

# Example 3
nums1_3 = [0, 0]
nums2_3 = [0, 0]
output_3 = findMedianSortedArrays(nums1_3, nums2_3)
print(output_3 == 0.00000)  # True","True
True
True",3,0
5,"def longestPalindrome(s: str) -> str:
    if len(s) < 2:
        return s
    
    n = len(s)
    dp = [[False for _ in range(n)] for _ in range(n)]
    maxLen = 1
    start = 0
    
    for i in range(n):
        dp[i][i] = True
    
    for i in range(n - 1, -1, -1):
        for j in range(i + 1, n):
            if s[i] == s[j]:
                if j - i == 1 or dp[i + 1][j - 1]:
                    dp[i][j] = True
                    if j - i + 1 > maxLen:
                        maxLen = j - i + 1
                        start = i
    
    return s[start:start + maxLen]

# Example 1
s = ""babad""
output_1 = longestPalindrome(s)
print(output_1 == ""bab"")  # True

# Example 2
s = ""cbbd""
output_2 = longestPalindrome(s)
print(output_2 == ""bb"")  # True

# Example 3
s = ""a""
output_3 = longestPalindrome(s)
print(output_3 == ""a"")  # True

# Example 4
s = ""ac""
output_4 = longestPalindrome(s)
print(output_4 == ""a"")  # True","False
True
True
True",3,1
6,"import unittest

def convert(s: str, numRows: int) -> str:
    if numRows == 1 or numRows >= len(s):
        return s
    
    rows = [[] for _ in range(numRows)]
    direction = 1
    row = 0
    
    for i in range(len(s)):
        rows[row].append(s[i])
        row += direction
        
        if row == numRows - 1 or row == 0:
            direction *= -1
    
    result = ''.join([''.join(row) for row in rows])
    return result

class TestZigZagConversion(unittest.TestCase):
    def test_example_1(self):
        self.assertEqual(convert('PAYPALISHIRING', 3), 'PAHNAPLSIIGYIR')
    
    def test_example_2(self):
        self.assertEqual(convert('PAYPALISHIRING', 4), 'PINALSIGYAHRPI')
    
    def test_example_3(self):
        self.assertEqual(convert('A', 1), 'A')

if __name__ == '__main__':
    unittest.main()",,0,0
7,"import math

def reverse_integer(x: int) -> int:
    sign = 1 if x >= 0 else -1
    x = abs(x)
    reversed_x = 0
    while x > 0:
        digit = x % 10
        reversed_x = reversed_x * 10 + digit
        x //= 10
    reversed_x *= sign
    if reversed_x < -2**31 or reversed_x > 2**31 - 1:
        return 0
    return reversed_x

# Example 1
input_1 = 123
output_1 = reverse_integer(input_1)
print(output_1 == 321)  # True

# Example 2
input_2 = -123
output_2 = reverse_integer(input_2)
print(output_2 == -321)  # True

# Example 3
input_3 = 120
output_3 = reverse_integer(input_3)
print(output_3 == 21)  # True

# Example 4
input_4 = 0
output_4 = reverse_integer(input_4)
print(output_4 == 0)  # True","True
True
True
True",4,0
8,"import sys

def myAtoi(s: str) -> int:
    """"""
    Converts a string to a 32-bit signed integer.

    Args:
        s: The string to convert.

    Returns:
        The integer representation of the string.
    """"""
    s = s.strip()
    if not s:
        return 0
    sign = 1
    if s[0] == '-':
        sign = -1
        s = s[1:]
    elif s[0] == '+':
        s = s[1:]
    result = 0
    for i in range(len(s)):
        if not s[i].isdigit():
            break
        result = result * 10 + int(s[i])
    result *= sign
    if result > 2**31 - 1:
        return 2**31 - 1
    elif result < -2**31:
        return -2**31
    return result

# Example 1
s = ""42""
output = myAtoi(s)
print(f""Input: {s}"")
print(f""Output: {output}"")
print(f""Expected Output: 42"")
print(f""Output matches expected: {output == 42}"")
print()

# Example 2
s = ""   -42""
output = myAtoi(s)
print(f""Input: {s}"")
print(f""Output: {output}"")
print(f""Expected Output: -42"")
print(f""Output matches expected: {output == -42}"")
print()

# Example 3
s = ""4193 with words""
output = myAtoi(s)
print(f""Input: {s}"")
print(f""Output: {output}"")
print(f""Expected Output: 4193"")
print(f""Output matches expected: {output == 4193}"")
print()

# Example 4
s = ""words and 987""
output = myAtoi(s)
print(f""Input: {s}"")
print(f""Output: {output}"")
print(f""Expected Output: 0"")
print(f""Output matches expected: {output == 0}"")
print()

# Example 5
s = ""-91283472332""
output = myAtoi(s)
print(f""Input: {s}"")
print(f""Output: {output}"")
print(f""Expected Output: -2147483648"")
print(f""Output matches expected: {output == -2147483648}"")
print()","Input: 42
Output: 42
Expected Output: 42
Output matches expected: True

Input:    -42
Output: -42
Expected Output: -42
Output matches expected: True

Input: 4193 with words
Output: 4193
Expected Output: 4193
Output matches expected: True

Input: words and 987
Output: 0
Expected Output: 0
Output matches expected: True

Input: -91283472332
Output: -2147483648
Expected Output: -2147483648
Output matches expected: True",5,0
9,"def isPalindrome(x: int) -> bool:
    if x < 0:
        return False
    original = x
    reversed = 0
    while x > 0:
        digit = x % 10
        reversed = reversed * 10 + digit
        x //= 10
    return original == reversed

# Example 1
x = 121
print(isPalindrome(x) == True)

# Example 2
x = -121
print(isPalindrome(x) == False)

# Example 3
x = 10
print(isPalindrome(x) == False)

# Example 4
x = -101
print(isPalindrome(x) == False) ","True
True
True
True",4,0
10,"def isMatch(s: str, p: str) -> bool:
    n = len(s)
    m = len(p)
    
    dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]
    dp[0][0] = True
    
    for j in range(2, m + 1):
        if p[j - 1] == '*':
            dp[0][j] = dp[0][j - 2]
    
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if p[j - 1] == s[i - 1] or p[j - 1] == '.':
                dp[i][j] = dp[i - 1][j - 1]
            elif p[j - 1] == '*':
                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))
    
    return dp[n][m]

# Example 1
s1 = ""aa""
p1 = ""a""
output1 = isMatch(s1, p1)
print(f""Example 1: {output1 == False}"")

# Example 2
s2 = ""aa""
p2 = ""a*""
output2 = isMatch(s2, p2)
print(f""Example 2: {output2 == True}"")

# Example 3
s3 = ""ab""
p3 = "".*""
output3 = isMatch(s3, p3)
print(f""Example 3: {output3 == True}"")

# Example 4
s4 = ""aab""
p4 = ""c*a*b""
output4 = isMatch(s4, p4)
print(f""Example 4: {output4 == True}"")

# Example 5
s5 = ""mississippi""
p5 = ""mis*is*p*.""
output5 = isMatch(s5, p5)
print(f""Example 5: {output5 == False}"")","Example 1: True
Example 2: True
Example 3: True
Example 4: True
Example 5: True",5,0
11,"import unittest

def maxArea(height):
    left = 0
    right = len(height) - 1
    max_area = 0
    while left < right:
        current_area = min(height[left], height[right]) * (right - left)
        max_area = max(max_area, current_area)
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return max_area

class TestMaxArea(unittest.TestCase):
    def test_example_1(self):
        self.assertEqual(maxArea([1,8,6,2,5,4,8,3,7]), 49)
    def test_example_2(self):
        self.assertEqual(maxArea([1,1]), 1)
    def test_example_3(self):
        self.assertEqual(maxArea([4,3,2,1,4]), 16)
    def test_example_4(self):
        self.assertEqual(maxArea([1,2,1]), 2)

if __name__ == '__main__':
    unittest.main()",,0,0
12,"import unittest

class Solution:
    def intToRoman(self, num: int) -> str:
        roman_map = {
            1000: 'M',
            900: 'CM',
            500: 'D',
            400: 'CD',
            100: 'C',
            90: 'XC',
            50: 'L',
            40: 'XL',
            10: 'X',
            9: 'IX',
            5: 'V',
            4: 'IV',
            1: 'I'
        }
        result = ''
        for value, symbol in roman_map.items():
            while num >= value:
                result += symbol
                num -= value
        return result

class TestRomanToInt(unittest.TestCase):
    def test_example_1(self):
        solution = Solution()
        self.assertEqual(solution.intToRoman(3), ""III"")

    def test_example_2(self):
        solution = Solution()
        self.assertEqual(solution.intToRoman(4), ""IV"")

    def test_example_3(self):
        solution = Solution()
        self.assertEqual(solution.intToRoman(9), ""IX"")

    def test_example_4(self):
        solution = Solution()
        self.assertEqual(solution.intToRoman(58), ""LVIII"")

    def test_example_5(self):
        solution = Solution()
        self.assertEqual(solution.intToRoman(1994), ""MCMXCIV"")


if __name__ == '__main__':
    unittest.main()",,0,0
13,"import unittest

class Solution:
    def romanToInt(self, s: str) -> int:
        roman_map = {
            'I': 1,
            'V': 5,
            'X': 10,
            'L': 50,
            'C': 100,
            'D': 500,
            'M': 1000
        }
        result = 0
        i = 0
        while i < len(s):
            current_symbol = s[i]
            next_symbol = s[i + 1] if i + 1 < len(s) else None
            if next_symbol and roman_map[current_symbol] < roman_map[next_symbol]:
                result += roman_map[next_symbol] - roman_map[current_symbol]
                i += 2
            else:
                result += roman_map[current_symbol]
                i += 1
        return result

class TestRomanToInt(unittest.TestCase):
    def test_example_1(self):
        s = ""III""
        expected_output = 3
        solution = Solution()
        self.assertEqual(solution.romanToInt(s), expected_output)
        print(f""Example 1: {solution.romanToInt(s) == expected_output}"")

    def test_example_2(self):
        s = ""IV""
        expected_output = 4
        solution = Solution()
        self.assertEqual(solution.romanToInt(s), expected_output)
        print(f""Example 2: {solution.romanToInt(s) == expected_output}"")

    def test_example_3(self):
        s = ""IX""
        expected_output = 9
        solution = Solution()
        self.assertEqual(solution.romanToInt(s), expected_output)
        print(f""Example 3: {solution.romanToInt(s) == expected_output}"")

    def test_example_4(self):
        s = ""LVIII""
        expected_output = 58
        solution = Solution()
        self.assertEqual(solution.romanToInt(s), expected_output)
        print(f""Example 4: {solution.romanToInt(s) == expected_output}"")

    def test_example_5(self):
        s = ""MCMXCIV""
        expected_output = 1994
        solution = Solution()
        self.assertEqual(solution.romanToInt(s), expected_output)
        print(f""Example 5: {solution.romanToInt(s) == expected_output}"")

if __name__ == '__main__':
    unittest.main()","Example 1: True
Example 2: True
Example 3: True
Example 4: True
Example 5: True",5,0
14,"def longestCommonPrefix(strs):
    if not strs:
        return """"
    prefix = strs[0]
    for i in range(1, len(strs)):
        while not strs[i].startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return """"
    return prefix

# Example 1
strs_1 = [""flower"",""flow"",""flight""]
output_1 = longestCommonPrefix(strs_1)
print(output_1 == ""fl"")  # True

# Example 2
strs_2 = [""dog"",""racecar"",""car""]
output_2 = longestCommonPrefix(strs_2)
print(output_2 == """")  # True","True
True",2,0
15,"import itertools

def threeSum(nums):
    result = []
    nums.sort()
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left = i + 1
        right = len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == 0:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < 0:
                left += 1
            else:
                right -= 1
    return result

# Example 1
nums1 = [-1,0,1,2,-1,-4]
output1 = threeSum(nums1)
print(output1 == [[-1,-1,2],[-1,0,1]])

# Example 2
nums2 = []
output2 = threeSum(nums2)
print(output2 == [])

# Example 3
nums3 = [0]
output3 = threeSum(nums3)
print(output3 == [])","True
True
True",3,0
16,"import sys

def threeSumClosest(nums, target):
    nums.sort()
    closest_sum = sys.maxsize
    for i in range(len(nums) - 2):
        left = i + 1
        right = len(nums) - 1
        while left < right:
            current_sum = nums[i] + nums[left] + nums[right]
            if abs(current_sum - target) < abs(closest_sum - target):
                closest_sum = current_sum
            if current_sum < target:
                left += 1
            else:
                right -= 1
    return closest_sum

# Example 1
nums1 = [-1, 2, 1, -4]
target1 = 1
output1 = threeSumClosest(nums1, target1)
print(output1 == 2)  # True

# Example 2
# No second example provided

# Example 3
# No third example provided",True,1,0
17,"import unittest

class Solution:
    def letterCombinations(self, digits: str) -> list[str]:
        if not digits:
            return []
        
        mapping = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        }
        
        result = ['']
        for digit in digits:
            temp = []
            for letter in mapping[digit]:
                for combination in result:
                    temp.append(combination + letter)
            result = temp
        return result

class TestLetterCombinations(unittest.TestCase):
    def test_example_1(self):
        digits = ""23""
        expected_output = [""ad"",""ae"",""af"",""bd"",""be"",""bf"",""cd"",""ce"",""cf""]
        self.assertEqual(Solution().letterCombinations(digits), expected_output)
        print(True)
    
    def test_example_2(self):
        digits = """"
        expected_output = []
        self.assertEqual(Solution().letterCombinations(digits), expected_output)
        print(True)
    
    def test_example_3(self):
        digits = ""2""
        expected_output = [""a"",""b"",""c""]
        self.assertEqual(Solution().letterCombinations(digits), expected_output)
        print(True)

if __name__ == '__main__':
    unittest.main()","True
True",2,0
18,"Got invalid return object. Expected key `input_3` to be present, but got {'problem_solution': '```python\nimport itertools\n\ndef fourSum(nums, target):\n    nums.sort()\n    quadruplets = []\n    for i in range(len(nums) - 3):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        for j in range(i + 1, len(nums) - 2):\n            if j > i + 1 and nums[j] == nums[j - 1]:\n                continue\n            left = j + 1\n            right = len(nums) - 1\n            while left < right:\n                current_sum = nums[i] + nums[j] + nums[left] + nums[right]\n                if current_sum == target:\n                    quadruplets.append([nums[i], nums[j], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n                elif current_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n    return quadruplets\n\n# Example 1\nnums1 = [1,0,-1,0,-2,2]\ntarget1 = 0\noutput1 = fourSum(nums1, target1)\nexpected_output1 = [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\nprint(output1 == expected_output1)\n\n# Example 2\nnums2 = []\ntarget2 = 0\noutput2 = fourSum(nums2, target2)\nexpected_output2 = []\nprint(output2 == expected_output2)\n```', 'input_1': 'nums1 = [1,0,-1,0,-2,2]', 'output_1': 'expected_output1 = [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]', 'input_2': 'nums2 = []', 'output_2': 'expected_output2 = []'}",ERROR,ERROR,ERROR
19,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def removeNthFromEnd(head, n):
    dummy = ListNode(0, head)
    first = dummy
    second = dummy
    
    # Move `first` pointer `n` steps ahead
    for i in range(n):
        first = first.next
    
    # Move both pointers until `first` reaches the end
    while first.next:
        first = first.next
        second = second.next
    
    # `second` now points to the node before the `nth` node from the end
    second.next = second.next.next
    
    return dummy.next

# Example 1
head1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))
input1 = head1
output1 = removeNthFromEnd(head1, 2)
print(output1.val, output1.next.val, output1.next.next.val, output1.next.next.next.val)
print(True if output1.val == 1 and output1.next.val == 2 and output1.next.next.val == 3 and output1.next.next.next.val == 5 else False)

# Example 2
head2 = ListNode(1)
input2 = head2
output2 = removeNthFromEnd(head2, 1)
print(output2)
print(True if output2 is None else False)

# Example 3
head3 = ListNode(1, ListNode(2))
input3 = head3
output3 = removeNthFromEnd(head3, 1)
print(output3.val)
print(True if output3.val == 1 else False)","1 2 3 5
True
None
True
1
True",3,0
20,"def is_valid(s: str) -> bool:
    stack = []
    parentheses = {')': '(', '}': '{', ']': '['}
    for char in s:
        if char in parentheses.values():
            stack.append(char)
        elif char in parentheses.keys():
            if stack and stack[-1] == parentheses[char]:
                stack.pop()
            else:
                return False
        else:
            return False
    return len(stack) == 0

# Example 1
s = ""()""
print(is_valid(s) == True)

# Example 2
s = ""()[]{}""
print(is_valid(s) == True)

# Example 3
s = ""(]""
print(is_valid(s) == False)

# Example 4
s = ""([)]""
print(is_valid(s) == False)

# Example 5
s = ""{[]}""
print(is_valid(s) == True) ","True
True
True
True
True",5,0
21,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode:
    dummy = ListNode()
    tail = dummy

    while l1 and l2:
        if l1.val <= l2.val:
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next

    if l1:
        tail.next = l1
    if l2:
        tail.next = l2

    return dummy.next

# Example 1
l1 = ListNode(1, ListNode(2, ListNode(4)))
l2 = ListNode(1, ListNode(3, ListNode(4)))
merged_list = mergeTwoLists(l1, l2)
output_1 = []
while merged_list:
    output_1.append(merged_list.val)
    merged_list = merged_list.next
print(output_1 == [1, 1, 2, 3, 4, 4])  # True

# Example 2
l1 = None
l2 = None
merged_list = mergeTwoLists(l1, l2)
output_2 = []
while merged_list:
    output_2.append(merged_list.val)
    merged_list = merged_list.next
print(output_2 == [])  # True

# Example 3
l1 = None
l2 = ListNode(0)
merged_list = mergeTwoLists(l1, l2)
output_3 = []
while merged_list:
    output_3.append(merged_list.val)
    merged_list = merged_list.next
print(output_3 == [0])  # True","True
True
True",3,0
22,"import unittest

def generateParenthesis(n: int) -> list[str]:
    result = []
    def backtrack(s: str, left: int, right: int):
        if len(s) == 2 * n:
            result.append(s)
            return
        if left < n:
            backtrack(s + ""("", left + 1, right)
        if right < left:
            backtrack(s + "")"", left, right + 1)
    backtrack("""", 0, 0)
    return result

class TestGenerateParenthesis(unittest.TestCase):
    def test_example_1(self):
        n = 3
        expected_output = ['((()))', '(()())', '(())()', '()(())', '()()()']
        self.assertEqual(generateParenthesis(n), expected_output)
        print(f""Input: {n}, Output: {generateParenthesis(n)}, Expected Output: {expected_output}, Result: {generateParenthesis(n) == expected_output}"")
    def test_example_2(self):
        n = 1
        expected_output = ['()']
        self.assertEqual(generateParenthesis(n), expected_output)
        print(f""Input: {n}, Output: {generateParenthesis(n)}, Expected Output: {expected_output}, Result: {generateParenthesis(n) == expected_output}"")

if __name__ == '__main__':
    unittest.main()","Input: 3, Output: ['((()))', '(()())', '(())()', '()(())', '()()()'], Expected Output: ['((()))', '(()())', '(())()', '()(())', '()()()'], Result: True
Input: 1, Output: ['()'], Expected Output: ['()'], Result: True",2,0
23,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeKLists(lists):
    if not lists:
        return None
    if len(lists) == 1:
        return lists[0]
    
    # Use a min-heap to store the heads of the linked lists
    import heapq
    heap = [(head.val, i, head) for i, head in enumerate(lists) if head]
    heapq.heapify(heap)
    
    dummy = ListNode(0)
    tail = dummy
    
    while heap:
        val, i, node = heapq.heappop(heap)
        tail.next = node
        tail = tail.next
        
        if node.next:
            heapq.heappush(heap, (node.next.val, i, node.next))
    
    return dummy.next

# Example 1
lists_1 = [[1,4,5],[1,3,4],[2,6]]
head_1 = ListNode(1)
head_1.next = ListNode(4)
head_1.next.next = ListNode(5)
head_2 = ListNode(1)
head_2.next = ListNode(3)
head_2.next.next = ListNode(4)
head_3 = ListNode(2)
head_3.next = ListNode(6)
lists_1 = [head_1, head_2, head_3]
output_1 = mergeKLists(lists_1)
print(output_1 == [1,1,2,3,4,4,5,6], ""Example 1"")

# Example 2
lists_2 = []
output_2 = mergeKLists(lists_2)
print(output_2 == [], ""Example 2"")

# Example 3
lists_3 = [[]]
output_3 = mergeKLists(lists_3)
print(output_3 == [], ""Example 3"")","False Example 1
False Example 2
True Example 3",1,2
24,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def swapPairs(head: ListNode) -> ListNode:
    dummy = ListNode(0, head)
    prev = dummy

    while prev.next and prev.next.next:
        # 1. Define the nodes to be swapped
        node1 = prev.next
        node2 = prev.next.next

        # 2. Swap the nodes
        prev.next = node2
        node1.next = node2.next
        node2.next = node1

        # 3. Move the previous pointer to the swapped node
        prev = node1

    return dummy.next

# Example 1
head1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4))))
output1 = swapPairs(head1)
print(output1.val, output1.next.val, output1.next.next.val, output1.next.next.next.val)  # Output: 2 1 4 3
print(True)

# Example 2
head2 = None
output2 = swapPairs(head2)
print(output2)  # Output: None
print(True)

# Example 3
head3 = ListNode(1)
output3 = swapPairs(head3)
print(output3.val)  # Output: 1
print(True)","2 1 4 3
True
None
True
1
True",3,0
25,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseKGroup(head: ListNode, k: int) -> ListNode:
    dummy = ListNode(0, head)
    groupPrev = dummy

    while True:
        kth = getKth(groupPrev, k)
        if not kth:
            break
        groupNext = kth.next

        # reverse group
        prev, curr = kth.next, groupPrev.next
        while curr != groupNext:
            tmp = curr.next
            curr.next = prev
            prev = curr
            curr = tmp

        tmp = groupPrev.next
        groupPrev.next = kth
        groupPrev = tmp

    return dummy.next

def getKth(curr, k):
    while curr and k > 0:
        curr = curr.next
        k -= 1
    return curr

# Example 1
head1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))
k1 = 2
output1 = reverseKGroup(head1, k1)
print(output1.val, output1.next.val, output1.next.next.val, output1.next.next.next.val, output1.next.next.next.next.val)
print(True)

# Example 2
head2 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))
k2 = 3
output2 = reverseKGroup(head2, k2)
print(output2.val, output2.next.val, output2.next.next.val, output2.next.next.next.val, output2.next.next.next.next.val)
print(True)

# Example 3
head3 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))
k3 = 1
output3 = reverseKGroup(head3, k3)
print(output3.val, output3.next.val, output3.next.next.val, output3.next.next.next.val, output3.next.next.next.next.val)
print(True)

# Example 4
head4 = ListNode(1)
k4 = 1
output4 = reverseKGroup(head4, k4)
print(output4.val)
print(True)","2 1 4 3 5
True
3 2 1 4 5
True
1 2 3 4 5
True
1
True",4,0
