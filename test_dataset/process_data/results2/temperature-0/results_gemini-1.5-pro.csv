ID,code,result,true_count,false_count
1,"def solution(nums, target):
    hashmap = {}
    for i in range(len(nums)):
        complement = target - nums[i]
        if complement in hashmap:
            return [i, hashmap[complement]]
        hashmap[nums[i]] = i


input_1 = [2,7,11,15]
output_1 = [0,1]
input_2 = [3,2,4]
output_2 = [1,2]
input_3 = [3,3]
output_3 = [0,1]

print(solution(input_1, 9) == output_1)
print(solution(input_2, 6) == output_2)
print(solution(input_3, 6) == output_3)","False
False
False",0,3
2,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(0)
        curr = dummy
        carry = 0

        while l1 or l2 or carry:
            val1 = l1.val if l1 else 0
            val2 = l2.val if l2 else 0

            total = val1 + val2 + carry
            carry = total // 10
            curr.next = ListNode(total % 10)

            curr = curr.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None

        return dummy.next

def create_linked_list(lst):
    head = None
    tail = None
    for val in lst:
        new_node = ListNode(val)
        if not head:
            head = new_node
            tail = new_node
        else:
            tail.next = new_node
            tail = new_node
    return head

def linked_list_to_list(head):
    lst = []
    curr = head
    while curr:
        lst.append(curr.val)
        curr = curr.next
    return lst

# Test cases
input_data = [
    ([2, 4, 3], [5, 6, 4]),
    ([0], [0]),
    ([9, 9, 9, 9, 9, 9, 9], [9, 9, 9, 9])
]
output_data = [
    [7, 0, 8],
    [0],
    [8, 9, 9, 9, 0, 0, 0, 1]
]

solution = Solution()

for i in range(len(input_data)):
    l1 = create_linked_list(input_data[i][0])
    l2 = create_linked_list(input_data[i][1])
    result = solution.addTwoNumbers(l1, l2)
    output = linked_list_to_list(result)
    print(output == output_data[i])
",,0,0
3,"def length_of_longest_substring(s: str) -> int:
    char_set = set()
    l = 0
    max_length = 0
    for r in range(len(s)):
        while s[r] in char_set:
            char_set.remove(s[l])
            l += 1
        char_set.add(s[r])
        max_length = max(max_length, r - l + 1)
    return max_length


input_1 = ""abcabcbb""
output_1 = 3
input_2 = ""bbbbb""
output_2 = 1
input_3 = ""pwwkew""
output_3 = 3
input_4 = """"
output_4 = 0

print(length_of_longest_substring(input_1) == output_1)
print(length_of_longest_substring(input_2) == output_2)
print(length_of_longest_substring(input_3) == output_3)
print(length_of_longest_substring(input_4) == output_4)","True
True
True
True",4,0
4,"class Solution:
    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -> float:
        m, n = len(nums1), len(nums2)
        if m > n:
            nums1, nums2, m, n = nums2, nums1, n, m
        imin, imax, half_len = 0, m, (m + n + 1) // 2
        while imin <= imax:
            i = (imin + imax) // 2
            j = half_len - i
            if i < m and nums2[j-1] > nums1[i]:
                imin = i + 1
            elif i > 0 and nums1[i-1] > nums2[j]:
                imax = i - 1
            else:
                if i == 0: max_left = nums2[j-1]
                elif j == 0: max_left = nums1[i-1]
                else: max_left = max(nums1[i-1], nums2[j-1])

                if (m + n) % 2 == 1:
                    return max_left

                if i == m: min_right = nums2[j]
                elif j == n: min_right = nums1[i]
                else: min_right = min(nums1[i], nums2[j])

                return (max_left + min_right) / 2.0

solution = Solution()

# Test Case 1
nums1 = [1, 3]
nums2 = [2]
expected_output = 2.00000
output = solution.findMedianSortedArrays(nums1, nums2)
print(f""Input: nums1 = {nums1}, nums2 = {nums2}\nExpected Output: {expected_output}\nOutput: {output}\nResult: {output == expected_output}"")

# Test Case 2
nums1 = [1, 2]
nums2 = [3, 4]
expected_output = 2.50000
output = solution.findMedianSortedArrays(nums1, nums2)
print(f""Input: nums1 = {nums1}, nums2 = {nums2}\nExpected Output: {expected_output}\nOutput: {output}\nResult: {output == expected_output}"")

# Test Case 3
nums1 = [0, 0]
nums2 = [0, 0]
expected_output = 0.00000
output = solution.findMedianSortedArrays(nums1, nums2)
print(f""Input: nums1 = {nums1}, nums2 = {nums2}\nExpected Output: {expected_output}\nOutput: {output}\nResult: {output == expected_output}"")","Input: nums1 = [1, 3], nums2 = [2]
Expected Output: 2.0
Output: 2
Result: True
Input: nums1 = [1, 2], nums2 = [3, 4]
Expected Output: 2.5
Output: 2.5
Result: True
Input: nums1 = [0, 0], nums2 = [0, 0]
Expected Output: 0.0
Output: 0.0
Result: True",3,0
5,"def longestPalindrome(s: str) -> str:
    n = len(s)
    dp = [[False] * n for _ in range(n)]
    max_len = 1
    start = 0

    for i in range(n - 1, -1, -1):
        dp[i][i] = True
        for j in range(i + 1, n):
            if s[i] == s[j] and (j - i == 1 or dp[i + 1][j - 1]):
                dp[i][j] = True
                if j - i + 1 > max_len:
                    max_len = j - i + 1
                    start = i
    return s[start : start + max_len]


# Test cases
inputs = [
    ""babad"",
    ""cbbd"",
    ""a"",
]
outputs = [
    ""bab"",
    ""bb"",
    ""a"",
]

for i in range(len(inputs)):
    output = longestPalindrome(inputs[i])
    print(output == outputs[i])","False
True
True",2,1
6,"def convert(s, numRows):
    if numRows == 1 or numRows >= len(s):
        return s
    rows = [''] * numRows
    row_index = 0
    direction = 1
    for char in s:
        rows[row_index] += char
        row_index += direction
        if row_index == numRows - 1 or row_index == 0:
            direction *= -1
    return ''.join(rows)


# Test cases
input_1 = ""PAYPALISHIRING""
input_2 = ""PAYPALISHIRING""
input_3 = ""A""

output_1 = ""PAHNAPLSIIGYIR""
output_2 = ""PINALSIGYAHRPI""
output_3 = ""A""

print(convert(input_1, 3) == output_1)
print(convert(input_2, 4) == output_2)
print(convert(input_3, 1) == output_3)","True
True
True",3,0
7,"def reverse_integer(x):
    sign = 1 if x >= 0 else -1
    x = abs(x)
    reversed_x = 0
    while x > 0:
        digit = x % 10
        reversed_x = reversed_x * 10 + digit
        x //= 10
    reversed_x = sign * reversed_x
    if reversed_x < -2**31 or reversed_x > 2**31 - 1:
        return 0
    return reversed_x

# Test cases
inputs = [123, -123, 120, 0]
outputs = [321, -321, 21, 0]

for i in range(len(inputs)):
    result = reverse_integer(inputs[i])
    print(f""Input: {inputs[i]}, Expected Output: {outputs[i]}, Result: {result}, Match: {result == outputs[i]}"")","Input: 123, Expected Output: 321, Result: 321, Match: True
Input: -123, Expected Output: -321, Result: -321, Match: True
Input: 120, Expected Output: 21, Result: 21, Match: True
Input: 0, Expected Output: 0, Result: 0, Match: True",4,0
8,"def myAtoi(s: str) -> int:
    s = s.strip()
    if len(s) == 0:
        return 0
    sign = 1
    if s[0] == '-':
        sign = -1
        s = s[1:]
    elif s[0] == '+':
        s = s[1:]
    result = 0
    for c in s:
        if not c.isdigit():
            break
        result = result * 10 + int(c)
    result *= sign
    if result > 2**31 - 1:
        return 2**31 - 1
    elif result < -2**31:
        return -2**31
    else:
        return result


# Test cases
inputs = [
    ""42"",
    ""   -42"",
    ""4193 with words"",
    ""words and 987"",
    ""-91283472332""
]
outputs = [
    42,
    -42,
    4193,
    0,
    -2147483648
]

for i in range(len(inputs)):
    output = myAtoi(inputs[i])
    print(output == outputs[i])","True
True
True
True
True",5,0
9,"def isPalindrome(x):
    if x < 0:
        return False
    div = 1
    while x // div >= 10:
        div *= 10
    while x != 0:
        left = x // div
        right = x % 10
        if left != right:
            return False
        x = (x % div) // 10
        div //= 100
    return True

print(isPalindrome(121) == True)
print(isPalindrome(-121) == False)
print(isPalindrome(10) == False)","True
True
True",3,0
10,429 Resource has been exhausted (e.g. check quota).,ERROR,ERROR,ERROR
11,429 Resource has been exhausted (e.g. check quota).,ERROR,ERROR,ERROR
12,"def intToRoman(num: int) -> str:
    symbol_map = {1: 'I', 4: 'IV', 5: 'V', 9: 'IX', 10: 'X', 40: 'XL', 50: 'L', 90: 'XC', 100: 'C', 400: 'XD', 500: 'D', 900: 'CM', 1000: 'M'}
    i = 12
    result = """"
    while num != 0:
        if list(symbol_map.keys())[i] <= num:
            result += list(symbol_map.values())[i]
            num -= list(symbol_map.keys())[i]
        else:
            i -= 1
    return result

print(f""Input: 3, Output: {intToRoman(3)}, Expected: III, Result: {intToRoman(3) == 'III'}"")
print(f""Input: 4, Output: {intToRoman(4)}, Expected: IV, Result: {intToRoman(4) == 'IV'}"")
print(f""Input: 9, Output: {intToRoman(9)}, Expected: IX, Result: {intToRoman(9) == 'IX'}"")
print(f""Input: 58, Output: {intToRoman(58)}, Expected: LVIII, Result: {intToRoman(58) == 'LVIII'}"")
print(f""Input: 1994, Output: {intToRoman(1994)}, Expected: MCMXCIV, Result: {intToRoman(1994) == 'MCMXCIV'}"")","Input: 3, Output: III, Expected: III, Result: True
Input: 4, Output: IV, Expected: IV, Result: True
Input: 9, Output: IX, Expected: IX, Result: True
Input: 58, Output: LVIII, Expected: LVIII, Result: True
Input: 1994, Output: MCMXCIV, Expected: MCMXCIV, Result: True",5,0
13,"def roman_to_integer(s: str) -> int:
    roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    n = len(s)
    num = roman_map[s[n - 1]]
    for i in range(n - 2, -1, -1):
        if roman_map[s[i]] >= roman_map[s[i + 1]]:
            num += roman_map[s[i]]
        else:
            num -= roman_map[s[i]]
    return num


input_1 = ""III""
output_1 = 3
input_2 = ""IV""
output_2 = 4
input_3 = ""IX""
output_3 = 9
input_4 = ""LVIII""
output_4 = 58
input_5 = ""MCMXCIV""
output_5 = 1994

print(roman_to_integer(input_1) == output_1)
print(roman_to_integer(input_2) == output_2)
print(roman_to_integer(input_3) == output_3)
print(roman_to_integer(input_4) == output_4)
print(roman_to_integer(input_5) == output_5)","True
True
True
True
True",5,0
14,"def longestCommonPrefix(strs):
    if not strs:
        return """"

    prefix = strs[0]
    for i in range(1, len(strs)):
        j = 0
        while j < len(prefix) and j < len(strs[i]) and prefix[j] == strs[i][j]:
            j += 1
        prefix = prefix[:j]
        if not prefix:
            return """"
    return prefix


input1 = [""flower"", ""flow"", ""flight""]
output1 = ""fl""
input2 = [""dog"", ""racecar"", ""car""]
output2 = """"

print(longestCommonPrefix(input1) == output1)
print(longestCommonPrefix(input2) == output2)","True
True",2,0
15,"def three_sum(nums):
    result = []
    nums.sort()
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total < 0:
                left += 1
            elif total > 0:
                right -= 1
            else:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
    return result


input1 = [-1, 0, 1, 2, -1, -4]
output1 = [[-1, -1, 2], [-1, 0, 1]]
print(three_sum(input1) == output1)

input2 = []
output2 = []
print(three_sum(input2) == output2)

input3 = [0]
output3 = []
print(three_sum(input3) == output3)","True
True
True",3,0
16,"def three_sum_closest(nums, target):
    nums.sort()
    closest_sum = float('inf')

    for i in range(len(nums) - 2):
        left = i + 1
        right = len(nums) - 1

        while left < right:
            current_sum = nums[i] + nums[left] + nums[right]

            if current_sum == target:
                return target

            if abs(current_sum - target) < abs(closest_sum - target):
                closest_sum = current_sum

            if current_sum < target:
                left += 1
            else:
                right -= 1

    return closest_sum


# Test cases
inputs = [([-1, 2, 1, -4], 1)]
outputs = [2]

for i in range(len(inputs)):
    nums, target = inputs[i]
    output = three_sum_closest(nums, target)
    print(output == outputs[i])",True,1,0
17,"def letterCombinations(digits):
    if not digits:
        return []

    mapping = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',
               '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}

    result = ['']
    for digit in digits:
        temp = []
        for letter in mapping[digit]:
            for combination in result:
                temp.append(combination + letter)
        result = temp
    return result


# Test cases
digits1 = ""23""
output1 = [""ad"",""ae"",""af"",""bd"",""be"",""bf"",""cd"",""ce"",""cf""]
digits2 = """"
output2 = []
digits3 = ""2""
output3 = [""a"",""b"",""c""]

print(letterCombinations(digits1) == output1)  
print(letterCombinations(digits2) == output2)  
print(letterCombinations(digits3) == output3)  ","False
True
True",2,1
18,"Got invalid return object. Expected key `input_3` to be present, but got {'problem_solution': '```python\ndef fourSum(nums, target):\n    nums.sort()\n    result = []\n    n = len(nums)\n\n    for i in range(n - 3):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        for j in range(i + 1, n - 2):\n            if j > i + 1 and nums[j] == nums[j - 1]:\n                continue\n            left = j + 1\n            right = n - 1\n            while left < right:\n                total = nums[i] + nums[j] + nums[left] + nums[right]\n                if total == target:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left - 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right + 1]:\n                        right -= 1\n                elif total < target:\n                    left += 1\n                else:\n                    right -= 1\n    return result\n\n\ninput_value_1 = [1,0,-1,0,-2,2]\ninput_value_2 = []\nexpected_output_1 = [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\nexpected_output_2 = []\n\nprint(f""Input 1: {fourSum(input_value_1, 0) == expected_output_1}"")\nprint(f""Input 2: {fourSum(input_value_2, 0) == expected_output_2}"")\n```', 'input_1': 'nums = [1,0,-1,0,-2,2]\ntarget = 0', 'output_1': '[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]', 'input_2': 'nums = []\ntarget = 0', 'output_2': '[]'}",ERROR,ERROR,ERROR
19,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head, n):
        dummy = ListNode(0, head)
        left = dummy
        right = head

        while n > 0 and right:
            right = right.next
            n -= 1

        while right:
            left = left.next
            right = right.next

        # Delete the node
        left.next = left.next.next

        return dummy.next

def print_linked_list(head):
    current = head
    values = []
    while current:
        values.append(current.val)
        current = current.next
    return values

# Test cases
test_cases = [
    ([1, 2, 3, 4, 5], 2, [1, 2, 3, 5]),
    ([1], 1, []),
    ([1, 2], 1, [1])
]

solution = Solution()
for i, (head_values, n, expected_output) in enumerate(test_cases):
    # Create the linked list from the input values
    head = ListNode(head_values[0]) if head_values else None
    current = head
    for val in head_values[1:]:
        current.next = ListNode(val)
        current = current.next

    result_head = solution.removeNthFromEnd(head, n)
    result = print_linked_list(result_head)
    print(f'Test case {i+1}: {result == expected_output}')",,0,0
20,"def isValid(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
    return not stack


# Test cases
inputs = [
    ""()"",
    ""()[]{}"",
    ""(]"",
    ""([)]"",
    ""{[]}""
]
outputs = [
    True,
    True,
    False,
    False,
    True
]

# Run tests and print results
for i in range(len(inputs)):
    result = isValid(inputs[i])
    print(result == outputs[i])","True
True
True
True
True",5,0
21,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(0)
        tail = dummy

        while l1 and l2:
            if l1.val < l2.val:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next

        if l1:
            tail.next = l1
        elif l2:
            tail.next = l2

        return dummy.next

def print_linked_list(head):
    result = []
    current = head
    while current:
        result.append(current.val)
        current = current.next
    return result

test_cases = [
    ([1, 2, 4], [1, 3, 4], [1, 1, 2, 3, 4, 4]),
    ([], [], []),
    ([], [0], [0]),
]

solution = Solution()

for i, (l1_list, l2_list, expected_output) in enumerate(test_cases):
    l1 = ListNode(0)
    current = l1
    for val in l1_list:
        current.next = ListNode(val)
        current = current.next
    l1 = l1.next

    l2 = ListNode(0)
    current = l2
    for val in l2_list:
        current.next = ListNode(val)
        current = current.next
    l2 = l2.next

    merged_list = solution.mergeTwoLists(l1, l2)
    output = print_linked_list(merged_list)

    print(f""Test Case {i+1}: {output == expected_output}"")",,0,0
22,"def generateParenthesis(n):
    result = []
    def backtrack(s, left, right):
        if len(s) == 2 * n:
            result.append(s)
            return
        if left < n:
            backtrack(s + '(', left + 1, right)
        if right < left:
            backtrack(s + ')', left, right + 1)
    backtrack('', 0, 0)
    return result


# Test cases
inputs = [3, 1]
outputs = [[""((()))"",""(()())"",""(())()"",""()(())"",""()()()""], [""()""]]

for i in range(len(inputs)):
    print(generateParenthesis(inputs[i]) == outputs[i])","True
True",2,0
23,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeKLists(lists):
    if not lists:
        return None

    while len(lists) > 1:
        mergedLists = []
        for i in range(0, len(lists), 2):
            l1 = lists[i]
            l2 = lists[i + 1] if i + 1 < len(lists) else None
            mergedLists.append(mergeTwoLists(l1, l2))
        lists = mergedLists
    return lists[0]

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    tail = dummy

    while l1 and l2:
        if l1.val < l2.val:
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next

    if l1:
        tail.next = l1
    if l2:
        tail.next = l2

    return dummy.next

def createLinkedList(values):
    if not values:
        return None
    head = ListNode(values[0])
    current = head
    for i in range(1, len(values)):
        current.next = ListNode(values[i])
        current = current.next
    return head

def linkedListToValues(head):
    values = []
    while head:
        values.append(head.val)
        head = head.next
    return values

# Test cases
inputs = [
    [[1,4,5],[1,3,4],[2,6]],
    [],
    [[]]
]
outputs = [
    [1,1,2,3,4,4,5,6],
    [],
    []
]

for i in range(len(inputs)):
    input_linked_lists = [createLinkedList(sublist) for sublist in inputs[i]]
    merged_list = mergeKLists(input_linked_lists)
    output_values = linkedListToValues(merged_list)
    print(output_values == outputs[i])","True
True
True",3,0
24,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        dummy = ListNode(0, head)
        prev, curr = dummy, head

        while curr and curr.next:
            # Save pointers
            second = curr.next
            nxt = curr.next.next

            # Swap nodes
            second.next = curr
            curr.next = nxt
            prev.next = second

            # Move pointers
            prev = curr
            curr = nxt

        return dummy.next


def print_linked_list(head):
    result = []
    current = head
    while current:
        result.append(current.val)
        current = current.next
    return result

# Test cases
head1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4))))
output1 = [2, 1, 4, 3]
print(f""Input 1: True"" if print_linked_list(Solution().swapPairs(head1)) == output1 else ""Input 1: False"")

head2 = None
output2 = []
print(f""Input 2: True"" if print_linked_list(Solution().swapPairs(head2)) == output2 else ""Input 2: False"")

head3 = ListNode(1)
output3 = [1]
print(f""Input 3: True"" if print_linked_list(Solution().swapPairs(head3)) == output3 else ""Input 3: False"")",,0,0
25,429 Resource has been exhausted (e.g. check quota).,ERROR,ERROR,ERROR
1,"def solution(nums, target):
    hashmap = {}
    for i in range(len(nums)):
        complement = target - nums[i]
        if complement in hashmap:
            return [i, hashmap[complement]]
        hashmap[nums[i]] = i


input_1 = [2,7,11,15]
output_1 = [0,1]
input_2 = [3,2,4]
output_2 = [1,2]
input_3 = [3,3]
output_3 = [0,1]

print(solution(input_1, 9) == output_1)
print(solution(input_2, 6) == output_2)
print(solution(input_3, 6) == output_3)","False
False
False",0,3
2,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(0)
        curr = dummy
        carry = 0

        while l1 or l2 or carry:
            val1 = l1.val if l1 else 0
            val2 = l2.val if l2 else 0

            total = val1 + val2 + carry
            carry = total // 10
            curr.next = ListNode(total % 10)

            curr = curr.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None

        return dummy.next

def create_linked_list(lst):
    head = None
    tail = None
    for val in lst:
        new_node = ListNode(val)
        if not head:
            head = new_node
            tail = new_node
        else:
            tail.next = new_node
            tail = new_node
    return head

def linked_list_to_list(head):
    lst = []
    curr = head
    while curr:
        lst.append(curr.val)
        curr = curr.next
    return lst

# Test cases
input_data = [
    ([2, 4, 3], [5, 6, 4]),
    ([0], [0]),
    ([9, 9, 9, 9, 9, 9, 9], [9, 9, 9, 9])
]
output_data = [
    [7, 0, 8],
    [0],
    [8, 9, 9, 9, 0, 0, 0, 1]
]

solution = Solution()

for i in range(len(input_data)):
    l1 = create_linked_list(input_data[i][0])
    l2 = create_linked_list(input_data[i][1])
    result = solution.addTwoNumbers(l1, l2)
    output = linked_list_to_list(result)
    print(output == output_data[i])
",,0,0
3,"def length_of_longest_substring(s: str) -> int:
    char_set = set()
    l = 0
    max_length = 0
    for r in range(len(s)):
        while s[r] in char_set:
            char_set.remove(s[l])
            l += 1
        char_set.add(s[r])
        max_length = max(max_length, r - l + 1)
    return max_length


input_1 = ""abcabcbb""
output_1 = 3
input_2 = ""bbbbb""
output_2 = 1
input_3 = ""pwwkew""
output_3 = 3
input_4 = """"
output_4 = 0

print(length_of_longest_substring(input_1) == output_1)
print(length_of_longest_substring(input_2) == output_2)
print(length_of_longest_substring(input_3) == output_3)
print(length_of_longest_substring(input_4) == output_4)","True
True
True
True",4,0
4,"class Solution:
    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -> float:
        m, n = len(nums1), len(nums2)
        if m > n:
            nums1, nums2, m, n = nums2, nums1, n, m
        imin, imax, half_len = 0, m, (m + n + 1) // 2
        while imin <= imax:
            i = (imin + imax) // 2
            j = half_len - i
            if i < m and nums2[j-1] > nums1[i]:
                imin = i + 1
            elif i > 0 and nums1[i-1] > nums2[j]:
                imax = i - 1
            else:
                if i == 0: max_left = nums2[j-1]
                elif j == 0: max_left = nums1[i-1]
                else: max_left = max(nums1[i-1], nums2[j-1])

                if (m + n) % 2 == 1:
                    return max_left

                if i == m: min_right = nums2[j]
                elif j == n: min_right = nums1[i]
                else: min_right = min(nums1[i], nums2[j])

                return (max_left + min_right) / 2.0

solution = Solution()

# Test Case 1
nums1 = [1, 3]
nums2 = [2]
expected_output = 2.00000
output = solution.findMedianSortedArrays(nums1, nums2)
print(f""Input: nums1 = {nums1}, nums2 = {nums2}\nExpected Output: {expected_output}\nOutput: {output}\nResult: {output == expected_output}"")

# Test Case 2
nums1 = [1, 2]
nums2 = [3, 4]
expected_output = 2.50000
output = solution.findMedianSortedArrays(nums1, nums2)
print(f""Input: nums1 = {nums1}, nums2 = {nums2}\nExpected Output: {expected_output}\nOutput: {output}\nResult: {output == expected_output}"")

# Test Case 3
nums1 = [0, 0]
nums2 = [0, 0]
expected_output = 0.00000
output = solution.findMedianSortedArrays(nums1, nums2)
print(f""Input: nums1 = {nums1}, nums2 = {nums2}\nExpected Output: {expected_output}\nOutput: {output}\nResult: {output == expected_output}"")","Input: nums1 = [1, 3], nums2 = [2]
Expected Output: 2.0
Output: 2
Result: True
Input: nums1 = [1, 2], nums2 = [3, 4]
Expected Output: 2.5
Output: 2.5
Result: True
Input: nums1 = [0, 0], nums2 = [0, 0]
Expected Output: 0.0
Output: 0.0
Result: True",3,0
5,"def longestPalindrome(s: str) -> str:
    n = len(s)
    dp = [[False] * n for _ in range(n)]
    max_len = 1
    start = 0

    for i in range(n - 1, -1, -1):
        dp[i][i] = True
        for j in range(i + 1, n):
            if s[i] == s[j] and (j - i == 1 or dp[i + 1][j - 1]):
                dp[i][j] = True
                if j - i + 1 > max_len:
                    max_len = j - i + 1
                    start = i
    return s[start : start + max_len]


# Test cases
inputs = [
    ""babad"",
    ""cbbd"",
    ""a"",
]
outputs = [
    ""bab"",
    ""bb"",
    ""a"",
]

for i in range(len(inputs)):
    output = longestPalindrome(inputs[i])
    print(output == outputs[i])","False
True
True",2,1
6,"def convert(s, numRows):
    if numRows == 1 or numRows >= len(s):
        return s
    rows = [''] * numRows
    row_index = 0
    direction = 1
    for char in s:
        rows[row_index] += char
        row_index += direction
        if row_index == numRows - 1 or row_index == 0:
            direction *= -1
    return ''.join(rows)


# Test cases
input_1 = ""PAYPALISHIRING""
input_2 = ""PAYPALISHIRING""
input_3 = ""A""

output_1 = ""PAHNAPLSIIGYIR""
output_2 = ""PINALSIGYAHRPI""
output_3 = ""A""

print(convert(input_1, 3) == output_1)
print(convert(input_2, 4) == output_2)
print(convert(input_3, 1) == output_3)","True
True
True",3,0
7,"def reverse_integer(x):
    sign = 1 if x >= 0 else -1
    x = abs(x)
    reversed_x = 0
    while x > 0:
        digit = x % 10
        reversed_x = reversed_x * 10 + digit
        x //= 10
    reversed_x = sign * reversed_x
    if reversed_x < -2**31 or reversed_x > 2**31 - 1:
        return 0
    return reversed_x

# Test cases
inputs = [123, -123, 120, 0]
outputs = [321, -321, 21, 0]

for i in range(len(inputs)):
    result = reverse_integer(inputs[i])
    print(f""Input: {inputs[i]}, Expected Output: {outputs[i]}, Result: {result}, Match: {result == outputs[i]}"")","Input: 123, Expected Output: 321, Result: 321, Match: True
Input: -123, Expected Output: -321, Result: -321, Match: True
Input: 120, Expected Output: 21, Result: 21, Match: True
Input: 0, Expected Output: 0, Result: 0, Match: True",4,0
8,"def myAtoi(s: str) -> int:
    s = s.strip()
    if len(s) == 0:
        return 0
    sign = 1
    if s[0] == '-':
        sign = -1
        s = s[1:]
    elif s[0] == '+':
        s = s[1:]
    result = 0
    for c in s:
        if not c.isdigit():
            break
        result = result * 10 + int(c)
    result *= sign
    if result > 2**31 - 1:
        return 2**31 - 1
    elif result < -2**31:
        return -2**31
    else:
        return result


# Test cases
inputs = [
    ""42"",
    ""   -42"",
    ""4193 with words"",
    ""words and 987"",
    ""-91283472332""
]
outputs = [
    42,
    -42,
    4193,
    0,
    -2147483648
]

for i in range(len(inputs)):
    output = myAtoi(inputs[i])
    print(output == outputs[i])","True
True
True
True
True",5,0
9,"def isPalindrome(x):
    if x < 0:
        return False
    div = 1
    while x // div >= 10:
        div *= 10
    while x != 0:
        left = x // div
        right = x % 10
        if left != right:
            return False
        x = (x % div) // 10
        div //= 100
    return True

print(isPalindrome(121) == True)
print(isPalindrome(-121) == False)
print(isPalindrome(10) == False)","True
True
True",3,0
10,429 Resource has been exhausted (e.g. check quota).,ERROR,ERROR,ERROR
11,429 Resource has been exhausted (e.g. check quota).,ERROR,ERROR,ERROR
12,"def intToRoman(num: int) -> str:
    symbol_map = {1: 'I', 4: 'IV', 5: 'V', 9: 'IX', 10: 'X', 40: 'XL', 50: 'L', 90: 'XC', 100: 'C', 400: 'XD', 500: 'D', 900: 'CM', 1000: 'M'}
    i = 12
    result = """"
    while num != 0:
        if list(symbol_map.keys())[i] <= num:
            result += list(symbol_map.values())[i]
            num -= list(symbol_map.keys())[i]
        else:
            i -= 1
    return result

print(f""Input: 3, Output: {intToRoman(3)}, Expected: III, Result: {intToRoman(3) == 'III'}"")
print(f""Input: 4, Output: {intToRoman(4)}, Expected: IV, Result: {intToRoman(4) == 'IV'}"")
print(f""Input: 9, Output: {intToRoman(9)}, Expected: IX, Result: {intToRoman(9) == 'IX'}"")
print(f""Input: 58, Output: {intToRoman(58)}, Expected: LVIII, Result: {intToRoman(58) == 'LVIII'}"")
print(f""Input: 1994, Output: {intToRoman(1994)}, Expected: MCMXCIV, Result: {intToRoman(1994) == 'MCMXCIV'}"")","Input: 3, Output: III, Expected: III, Result: True
Input: 4, Output: IV, Expected: IV, Result: True
Input: 9, Output: IX, Expected: IX, Result: True
Input: 58, Output: LVIII, Expected: LVIII, Result: True
Input: 1994, Output: MCMXCIV, Expected: MCMXCIV, Result: True",5,0
13,"def roman_to_integer(s: str) -> int:
    roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    n = len(s)
    num = roman_map[s[n - 1]]
    for i in range(n - 2, -1, -1):
        if roman_map[s[i]] >= roman_map[s[i + 1]]:
            num += roman_map[s[i]]
        else:
            num -= roman_map[s[i]]
    return num


input_1 = ""III""
output_1 = 3
input_2 = ""IV""
output_2 = 4
input_3 = ""IX""
output_3 = 9
input_4 = ""LVIII""
output_4 = 58
input_5 = ""MCMXCIV""
output_5 = 1994

print(roman_to_integer(input_1) == output_1)
print(roman_to_integer(input_2) == output_2)
print(roman_to_integer(input_3) == output_3)
print(roman_to_integer(input_4) == output_4)
print(roman_to_integer(input_5) == output_5)","True
True
True
True
True",5,0
14,"def longestCommonPrefix(strs):
    if not strs:
        return """"

    prefix = strs[0]
    for i in range(1, len(strs)):
        j = 0
        while j < len(prefix) and j < len(strs[i]) and prefix[j] == strs[i][j]:
            j += 1
        prefix = prefix[:j]
        if not prefix:
            return """"
    return prefix


input1 = [""flower"", ""flow"", ""flight""]
output1 = ""fl""
input2 = [""dog"", ""racecar"", ""car""]
output2 = """"

print(longestCommonPrefix(input1) == output1)
print(longestCommonPrefix(input2) == output2)","True
True",2,0
15,"def three_sum(nums):
    result = []
    nums.sort()
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total < 0:
                left += 1
            elif total > 0:
                right -= 1
            else:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
    return result


input1 = [-1, 0, 1, 2, -1, -4]
output1 = [[-1, -1, 2], [-1, 0, 1]]
print(three_sum(input1) == output1)

input2 = []
output2 = []
print(three_sum(input2) == output2)

input3 = [0]
output3 = []
print(three_sum(input3) == output3)","True
True
True",3,0
16,"def three_sum_closest(nums, target):
    nums.sort()
    closest_sum = float('inf')

    for i in range(len(nums) - 2):
        left = i + 1
        right = len(nums) - 1

        while left < right:
            current_sum = nums[i] + nums[left] + nums[right]

            if current_sum == target:
                return target

            if abs(current_sum - target) < abs(closest_sum - target):
                closest_sum = current_sum

            if current_sum < target:
                left += 1
            else:
                right -= 1

    return closest_sum


# Test cases
inputs = [([-1, 2, 1, -4], 1)]
outputs = [2]

for i in range(len(inputs)):
    nums, target = inputs[i]
    output = three_sum_closest(nums, target)
    print(output == outputs[i])",True,1,0
17,"def letterCombinations(digits):
    if not digits:
        return []

    mapping = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',
               '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}

    result = ['']
    for digit in digits:
        temp = []
        for letter in mapping[digit]:
            for combination in result:
                temp.append(combination + letter)
        result = temp
    return result


# Test cases
digits1 = ""23""
output1 = [""ad"",""ae"",""af"",""bd"",""be"",""bf"",""cd"",""ce"",""cf""]
digits2 = """"
output2 = []
digits3 = ""2""
output3 = [""a"",""b"",""c""]

print(letterCombinations(digits1) == output1)  
print(letterCombinations(digits2) == output2)  
print(letterCombinations(digits3) == output3)  ","False
True
True",2,1
18,"Got invalid return object. Expected key `input_3` to be present, but got {'problem_solution': '```python\ndef fourSum(nums, target):\n    nums.sort()\n    result = []\n    n = len(nums)\n\n    for i in range(n - 3):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        for j in range(i + 1, n - 2):\n            if j > i + 1 and nums[j] == nums[j - 1]:\n                continue\n            left = j + 1\n            right = n - 1\n            while left < right:\n                total = nums[i] + nums[j] + nums[left] + nums[right]\n                if total == target:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left - 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right + 1]:\n                        right -= 1\n                elif total < target:\n                    left += 1\n                else:\n                    right -= 1\n    return result\n\n\ninput_value_1 = [1,0,-1,0,-2,2]\ninput_value_2 = []\nexpected_output_1 = [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\nexpected_output_2 = []\n\nprint(f""Input 1: {fourSum(input_value_1, 0) == expected_output_1}"")\nprint(f""Input 2: {fourSum(input_value_2, 0) == expected_output_2}"")\n```', 'input_1': 'nums = [1,0,-1,0,-2,2]\ntarget = 0', 'output_1': '[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]', 'input_2': 'nums = []\ntarget = 0', 'output_2': '[]'}",ERROR,ERROR,ERROR
19,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head, n):
        dummy = ListNode(0, head)
        left = dummy
        right = head

        while n > 0 and right:
            right = right.next
            n -= 1

        while right:
            left = left.next
            right = right.next

        # Delete the node
        left.next = left.next.next

        return dummy.next

def print_linked_list(head):
    current = head
    values = []
    while current:
        values.append(current.val)
        current = current.next
    return values

# Test cases
test_cases = [
    ([1, 2, 3, 4, 5], 2, [1, 2, 3, 5]),
    ([1], 1, []),
    ([1, 2], 1, [1])
]

solution = Solution()
for i, (head_values, n, expected_output) in enumerate(test_cases):
    # Create the linked list from the input values
    head = ListNode(head_values[0]) if head_values else None
    current = head
    for val in head_values[1:]:
        current.next = ListNode(val)
        current = current.next

    result_head = solution.removeNthFromEnd(head, n)
    result = print_linked_list(result_head)
    print(f'Test case {i+1}: {result == expected_output}')",,0,0
20,"def isValid(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
    return not stack


# Test cases
inputs = [
    ""()"",
    ""()[]{}"",
    ""(]"",
    ""([)]"",
    ""{[]}""
]
outputs = [
    True,
    True,
    False,
    False,
    True
]

# Run tests and print results
for i in range(len(inputs)):
    result = isValid(inputs[i])
    print(result == outputs[i])","True
True
True
True
True",5,0
21,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(0)
        tail = dummy

        while l1 and l2:
            if l1.val < l2.val:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next

        if l1:
            tail.next = l1
        elif l2:
            tail.next = l2

        return dummy.next

def print_linked_list(head):
    result = []
    current = head
    while current:
        result.append(current.val)
        current = current.next
    return result

test_cases = [
    ([1, 2, 4], [1, 3, 4], [1, 1, 2, 3, 4, 4]),
    ([], [], []),
    ([], [0], [0]),
]

solution = Solution()

for i, (l1_list, l2_list, expected_output) in enumerate(test_cases):
    l1 = ListNode(0)
    current = l1
    for val in l1_list:
        current.next = ListNode(val)
        current = current.next
    l1 = l1.next

    l2 = ListNode(0)
    current = l2
    for val in l2_list:
        current.next = ListNode(val)
        current = current.next
    l2 = l2.next

    merged_list = solution.mergeTwoLists(l1, l2)
    output = print_linked_list(merged_list)

    print(f""Test Case {i+1}: {output == expected_output}"")",,0,0
22,"def generateParenthesis(n):
    result = []
    def backtrack(s, left, right):
        if len(s) == 2 * n:
            result.append(s)
            return
        if left < n:
            backtrack(s + '(', left + 1, right)
        if right < left:
            backtrack(s + ')', left, right + 1)
    backtrack('', 0, 0)
    return result


# Test cases
inputs = [3, 1]
outputs = [[""((()))"",""(()())"",""(())()"",""()(())"",""()()()""], [""()""]]

for i in range(len(inputs)):
    print(generateParenthesis(inputs[i]) == outputs[i])","True
True",2,0
23,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeKLists(lists):
    if not lists:
        return None

    while len(lists) > 1:
        mergedLists = []
        for i in range(0, len(lists), 2):
            l1 = lists[i]
            l2 = lists[i + 1] if i + 1 < len(lists) else None
            mergedLists.append(mergeTwoLists(l1, l2))
        lists = mergedLists
    return lists[0]

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    tail = dummy

    while l1 and l2:
        if l1.val < l2.val:
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next

    if l1:
        tail.next = l1
    if l2:
        tail.next = l2

    return dummy.next

def createLinkedList(values):
    if not values:
        return None
    head = ListNode(values[0])
    current = head
    for i in range(1, len(values)):
        current.next = ListNode(values[i])
        current = current.next
    return head

def linkedListToValues(head):
    values = []
    while head:
        values.append(head.val)
        head = head.next
    return values

# Test cases
inputs = [
    [[1,4,5],[1,3,4],[2,6]],
    [],
    [[]]
]
outputs = [
    [1,1,2,3,4,4,5,6],
    [],
    []
]

for i in range(len(inputs)):
    input_linked_lists = [createLinkedList(sublist) for sublist in inputs[i]]
    merged_list = mergeKLists(input_linked_lists)
    output_values = linkedListToValues(merged_list)
    print(output_values == outputs[i])","True
True
True",3,0
24,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        dummy = ListNode(0, head)
        prev, curr = dummy, head

        while curr and curr.next:
            # Save pointers
            second = curr.next
            nxt = curr.next.next

            # Swap nodes
            second.next = curr
            curr.next = nxt
            prev.next = second

            # Move pointers
            prev = curr
            curr = nxt

        return dummy.next


def print_linked_list(head):
    result = []
    current = head
    while current:
        result.append(current.val)
        current = current.next
    return result

# Test cases
head1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4))))
output1 = [2, 1, 4, 3]
print(f""Input 1: True"" if print_linked_list(Solution().swapPairs(head1)) == output1 else ""Input 1: False"")

head2 = None
output2 = []
print(f""Input 2: True"" if print_linked_list(Solution().swapPairs(head2)) == output2 else ""Input 2: False"")

head3 = ListNode(1)
output3 = [1]
print(f""Input 3: True"" if print_linked_list(Solution().swapPairs(head3)) == output3 else ""Input 3: False"")",,0,0
25,429 Resource has been exhausted (e.g. check quota).,ERROR,ERROR,ERROR
10,"import re

def isMatch(s: str, p: str) -> bool:
    return re.fullmatch(p, s) is not None

s1 = ""aa""
p1 = ""a""
output1 = isMatch(s1, p1)
expected_output1 = False
print(f""Test 1: {output1 == expected_output1}"")

s2 = ""aa""
p2 = ""a*""
output2 = isMatch(s2, p2)
expected_output2 = True
print(f""Test 2: {output2 == expected_output2}"")

s3 = ""ab""
p3 = "".*""
output3 = isMatch(s3, p3)
expected_output3 = True
print(f""Test 3: {output3 == expected_output3}"")","Test 1: True
Test 2: True
Test 3: True",3,0
11,429 Resource has been exhausted (e.g. check quota).,ERROR,ERROR,ERROR
1,"def solution(nums, target):
    hashmap = {}
    for i in range(len(nums)):
        complement = target - nums[i]
        if complement in hashmap:
            return [i, hashmap[complement]]
        hashmap[nums[i]] = i


input_1 = [2,7,11,15]
output_1 = [0,1]
input_2 = [3,2,4]
output_2 = [1,2]
input_3 = [3,3]
output_3 = [0,1]

print(solution(input_1, 9) == output_1)
print(solution(input_2, 6) == output_2)
print(solution(input_3, 6) == output_3)","False
False
False",0,3
2,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(0)
        curr = dummy
        carry = 0

        while l1 or l2 or carry:
            val1 = l1.val if l1 else 0
            val2 = l2.val if l2 else 0

            total = val1 + val2 + carry
            carry = total // 10
            curr.next = ListNode(total % 10)

            curr = curr.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None

        return dummy.next

def create_linked_list(lst):
    head = None
    tail = None
    for val in lst:
        new_node = ListNode(val)
        if not head:
            head = new_node
            tail = new_node
        else:
            tail.next = new_node
            tail = new_node
    return head

def linked_list_to_list(head):
    lst = []
    curr = head
    while curr:
        lst.append(curr.val)
        curr = curr.next
    return lst

# Test cases
input_data = [
    ([2, 4, 3], [5, 6, 4]),
    ([0], [0]),
    ([9, 9, 9, 9, 9, 9, 9], [9, 9, 9, 9])
]
output_data = [
    [7, 0, 8],
    [0],
    [8, 9, 9, 9, 0, 0, 0, 1]
]

solution = Solution()

for i in range(len(input_data)):
    l1 = create_linked_list(input_data[i][0])
    l2 = create_linked_list(input_data[i][1])
    result = solution.addTwoNumbers(l1, l2)
    output = linked_list_to_list(result)
    print(output == output_data[i])
",,0,0
3,"def length_of_longest_substring(s: str) -> int:
    char_set = set()
    l = 0
    max_length = 0
    for r in range(len(s)):
        while s[r] in char_set:
            char_set.remove(s[l])
            l += 1
        char_set.add(s[r])
        max_length = max(max_length, r - l + 1)
    return max_length


input_1 = ""abcabcbb""
output_1 = 3
input_2 = ""bbbbb""
output_2 = 1
input_3 = ""pwwkew""
output_3 = 3
input_4 = """"
output_4 = 0

print(length_of_longest_substring(input_1) == output_1)
print(length_of_longest_substring(input_2) == output_2)
print(length_of_longest_substring(input_3) == output_3)
print(length_of_longest_substring(input_4) == output_4)","True
True
True
True",4,0
4,"class Solution:
    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -> float:
        m, n = len(nums1), len(nums2)
        if m > n:
            nums1, nums2, m, n = nums2, nums1, n, m
        imin, imax, half_len = 0, m, (m + n + 1) // 2
        while imin <= imax:
            i = (imin + imax) // 2
            j = half_len - i
            if i < m and nums2[j-1] > nums1[i]:
                imin = i + 1
            elif i > 0 and nums1[i-1] > nums2[j]:
                imax = i - 1
            else:
                if i == 0: max_left = nums2[j-1]
                elif j == 0: max_left = nums1[i-1]
                else: max_left = max(nums1[i-1], nums2[j-1])

                if (m + n) % 2 == 1:
                    return max_left

                if i == m: min_right = nums2[j]
                elif j == n: min_right = nums1[i]
                else: min_right = min(nums1[i], nums2[j])

                return (max_left + min_right) / 2.0

solution = Solution()

# Test Case 1
nums1 = [1, 3]
nums2 = [2]
expected_output = 2.00000
output = solution.findMedianSortedArrays(nums1, nums2)
print(f""Input: nums1 = {nums1}, nums2 = {nums2}\nExpected Output: {expected_output}\nOutput: {output}\nResult: {output == expected_output}"")

# Test Case 2
nums1 = [1, 2]
nums2 = [3, 4]
expected_output = 2.50000
output = solution.findMedianSortedArrays(nums1, nums2)
print(f""Input: nums1 = {nums1}, nums2 = {nums2}\nExpected Output: {expected_output}\nOutput: {output}\nResult: {output == expected_output}"")

# Test Case 3
nums1 = [0, 0]
nums2 = [0, 0]
expected_output = 0.00000
output = solution.findMedianSortedArrays(nums1, nums2)
print(f""Input: nums1 = {nums1}, nums2 = {nums2}\nExpected Output: {expected_output}\nOutput: {output}\nResult: {output == expected_output}"")","Input: nums1 = [1, 3], nums2 = [2]
Expected Output: 2.0
Output: 2
Result: True
Input: nums1 = [1, 2], nums2 = [3, 4]
Expected Output: 2.5
Output: 2.5
Result: True
Input: nums1 = [0, 0], nums2 = [0, 0]
Expected Output: 0.0
Output: 0.0
Result: True",3,0
5,"def longestPalindrome(s: str) -> str:
    n = len(s)
    dp = [[False] * n for _ in range(n)]
    max_len = 1
    start = 0

    for i in range(n - 1, -1, -1):
        dp[i][i] = True
        for j in range(i + 1, n):
            if s[i] == s[j] and (j - i == 1 or dp[i + 1][j - 1]):
                dp[i][j] = True
                if j - i + 1 > max_len:
                    max_len = j - i + 1
                    start = i
    return s[start : start + max_len]


# Test cases
inputs = [
    ""babad"",
    ""cbbd"",
    ""a"",
]
outputs = [
    ""bab"",
    ""bb"",
    ""a"",
]

for i in range(len(inputs)):
    output = longestPalindrome(inputs[i])
    print(output == outputs[i])","False
True
True",2,1
6,"def convert(s, numRows):
    if numRows == 1 or numRows >= len(s):
        return s
    rows = [''] * numRows
    row_index = 0
    direction = 1
    for char in s:
        rows[row_index] += char
        row_index += direction
        if row_index == numRows - 1 or row_index == 0:
            direction *= -1
    return ''.join(rows)


# Test cases
input_1 = ""PAYPALISHIRING""
input_2 = ""PAYPALISHIRING""
input_3 = ""A""

output_1 = ""PAHNAPLSIIGYIR""
output_2 = ""PINALSIGYAHRPI""
output_3 = ""A""

print(convert(input_1, 3) == output_1)
print(convert(input_2, 4) == output_2)
print(convert(input_3, 1) == output_3)","True
True
True",3,0
7,"def reverse_integer(x):
    sign = 1 if x >= 0 else -1
    x = abs(x)
    reversed_x = 0
    while x > 0:
        digit = x % 10
        reversed_x = reversed_x * 10 + digit
        x //= 10
    reversed_x = sign * reversed_x
    if reversed_x < -2**31 or reversed_x > 2**31 - 1:
        return 0
    return reversed_x

# Test cases
inputs = [123, -123, 120, 0]
outputs = [321, -321, 21, 0]

for i in range(len(inputs)):
    result = reverse_integer(inputs[i])
    print(f""Input: {inputs[i]}, Expected Output: {outputs[i]}, Result: {result}, Match: {result == outputs[i]}"")","Input: 123, Expected Output: 321, Result: 321, Match: True
Input: -123, Expected Output: -321, Result: -321, Match: True
Input: 120, Expected Output: 21, Result: 21, Match: True
Input: 0, Expected Output: 0, Result: 0, Match: True",4,0
8,"def myAtoi(s: str) -> int:
    s = s.strip()
    if len(s) == 0:
        return 0
    sign = 1
    if s[0] == '-':
        sign = -1
        s = s[1:]
    elif s[0] == '+':
        s = s[1:]
    result = 0
    for c in s:
        if not c.isdigit():
            break
        result = result * 10 + int(c)
    result *= sign
    if result > 2**31 - 1:
        return 2**31 - 1
    elif result < -2**31:
        return -2**31
    else:
        return result


# Test cases
inputs = [
    ""42"",
    ""   -42"",
    ""4193 with words"",
    ""words and 987"",
    ""-91283472332""
]
outputs = [
    42,
    -42,
    4193,
    0,
    -2147483648
]

for i in range(len(inputs)):
    output = myAtoi(inputs[i])
    print(output == outputs[i])","True
True
True
True
True",5,0
9,"def isPalindrome(x):
    if x < 0:
        return False
    div = 1
    while x // div >= 10:
        div *= 10
    while x != 0:
        left = x // div
        right = x % 10
        if left != right:
            return False
        x = (x % div) // 10
        div //= 100
    return True

print(isPalindrome(121) == True)
print(isPalindrome(-121) == False)
print(isPalindrome(10) == False)","True
True
True",3,0
10,429 Resource has been exhausted (e.g. check quota).,ERROR,ERROR,ERROR
11,429 Resource has been exhausted (e.g. check quota).,ERROR,ERROR,ERROR
12,"def intToRoman(num: int) -> str:
    symbol_map = {1: 'I', 4: 'IV', 5: 'V', 9: 'IX', 10: 'X', 40: 'XL', 50: 'L', 90: 'XC', 100: 'C', 400: 'XD', 500: 'D', 900: 'CM', 1000: 'M'}
    i = 12
    result = """"
    while num != 0:
        if list(symbol_map.keys())[i] <= num:
            result += list(symbol_map.values())[i]
            num -= list(symbol_map.keys())[i]
        else:
            i -= 1
    return result

print(f""Input: 3, Output: {intToRoman(3)}, Expected: III, Result: {intToRoman(3) == 'III'}"")
print(f""Input: 4, Output: {intToRoman(4)}, Expected: IV, Result: {intToRoman(4) == 'IV'}"")
print(f""Input: 9, Output: {intToRoman(9)}, Expected: IX, Result: {intToRoman(9) == 'IX'}"")
print(f""Input: 58, Output: {intToRoman(58)}, Expected: LVIII, Result: {intToRoman(58) == 'LVIII'}"")
print(f""Input: 1994, Output: {intToRoman(1994)}, Expected: MCMXCIV, Result: {intToRoman(1994) == 'MCMXCIV'}"")","Input: 3, Output: III, Expected: III, Result: True
Input: 4, Output: IV, Expected: IV, Result: True
Input: 9, Output: IX, Expected: IX, Result: True
Input: 58, Output: LVIII, Expected: LVIII, Result: True
Input: 1994, Output: MCMXCIV, Expected: MCMXCIV, Result: True",5,0
13,"def roman_to_integer(s: str) -> int:
    roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    n = len(s)
    num = roman_map[s[n - 1]]
    for i in range(n - 2, -1, -1):
        if roman_map[s[i]] >= roman_map[s[i + 1]]:
            num += roman_map[s[i]]
        else:
            num -= roman_map[s[i]]
    return num


input_1 = ""III""
output_1 = 3
input_2 = ""IV""
output_2 = 4
input_3 = ""IX""
output_3 = 9
input_4 = ""LVIII""
output_4 = 58
input_5 = ""MCMXCIV""
output_5 = 1994

print(roman_to_integer(input_1) == output_1)
print(roman_to_integer(input_2) == output_2)
print(roman_to_integer(input_3) == output_3)
print(roman_to_integer(input_4) == output_4)
print(roman_to_integer(input_5) == output_5)","True
True
True
True
True",5,0
14,"def longestCommonPrefix(strs):
    if not strs:
        return """"

    prefix = strs[0]
    for i in range(1, len(strs)):
        j = 0
        while j < len(prefix) and j < len(strs[i]) and prefix[j] == strs[i][j]:
            j += 1
        prefix = prefix[:j]
        if not prefix:
            return """"
    return prefix


input1 = [""flower"", ""flow"", ""flight""]
output1 = ""fl""
input2 = [""dog"", ""racecar"", ""car""]
output2 = """"

print(longestCommonPrefix(input1) == output1)
print(longestCommonPrefix(input2) == output2)","True
True",2,0
15,"def three_sum(nums):
    result = []
    nums.sort()
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total < 0:
                left += 1
            elif total > 0:
                right -= 1
            else:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
    return result


input1 = [-1, 0, 1, 2, -1, -4]
output1 = [[-1, -1, 2], [-1, 0, 1]]
print(three_sum(input1) == output1)

input2 = []
output2 = []
print(three_sum(input2) == output2)

input3 = [0]
output3 = []
print(three_sum(input3) == output3)","True
True
True",3,0
16,"def three_sum_closest(nums, target):
    nums.sort()
    closest_sum = float('inf')

    for i in range(len(nums) - 2):
        left = i + 1
        right = len(nums) - 1

        while left < right:
            current_sum = nums[i] + nums[left] + nums[right]

            if current_sum == target:
                return target

            if abs(current_sum - target) < abs(closest_sum - target):
                closest_sum = current_sum

            if current_sum < target:
                left += 1
            else:
                right -= 1

    return closest_sum


# Test cases
inputs = [([-1, 2, 1, -4], 1)]
outputs = [2]

for i in range(len(inputs)):
    nums, target = inputs[i]
    output = three_sum_closest(nums, target)
    print(output == outputs[i])",True,1,0
17,"def letterCombinations(digits):
    if not digits:
        return []

    mapping = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',
               '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}

    result = ['']
    for digit in digits:
        temp = []
        for letter in mapping[digit]:
            for combination in result:
                temp.append(combination + letter)
        result = temp
    return result


# Test cases
digits1 = ""23""
output1 = [""ad"",""ae"",""af"",""bd"",""be"",""bf"",""cd"",""ce"",""cf""]
digits2 = """"
output2 = []
digits3 = ""2""
output3 = [""a"",""b"",""c""]

print(letterCombinations(digits1) == output1)  
print(letterCombinations(digits2) == output2)  
print(letterCombinations(digits3) == output3)  ","False
True
True",2,1
18,"Got invalid return object. Expected key `input_3` to be present, but got {'problem_solution': '```python\ndef fourSum(nums, target):\n    nums.sort()\n    result = []\n    n = len(nums)\n\n    for i in range(n - 3):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        for j in range(i + 1, n - 2):\n            if j > i + 1 and nums[j] == nums[j - 1]:\n                continue\n            left = j + 1\n            right = n - 1\n            while left < right:\n                total = nums[i] + nums[j] + nums[left] + nums[right]\n                if total == target:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left - 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right + 1]:\n                        right -= 1\n                elif total < target:\n                    left += 1\n                else:\n                    right -= 1\n    return result\n\n\ninput_value_1 = [1,0,-1,0,-2,2]\ninput_value_2 = []\nexpected_output_1 = [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\nexpected_output_2 = []\n\nprint(f""Input 1: {fourSum(input_value_1, 0) == expected_output_1}"")\nprint(f""Input 2: {fourSum(input_value_2, 0) == expected_output_2}"")\n```', 'input_1': 'nums = [1,0,-1,0,-2,2]\ntarget = 0', 'output_1': '[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]', 'input_2': 'nums = []\ntarget = 0', 'output_2': '[]'}",ERROR,ERROR,ERROR
19,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head, n):
        dummy = ListNode(0, head)
        left = dummy
        right = head

        while n > 0 and right:
            right = right.next
            n -= 1

        while right:
            left = left.next
            right = right.next

        # Delete the node
        left.next = left.next.next

        return dummy.next

def print_linked_list(head):
    current = head
    values = []
    while current:
        values.append(current.val)
        current = current.next
    return values

# Test cases
test_cases = [
    ([1, 2, 3, 4, 5], 2, [1, 2, 3, 5]),
    ([1], 1, []),
    ([1, 2], 1, [1])
]

solution = Solution()
for i, (head_values, n, expected_output) in enumerate(test_cases):
    # Create the linked list from the input values
    head = ListNode(head_values[0]) if head_values else None
    current = head
    for val in head_values[1:]:
        current.next = ListNode(val)
        current = current.next

    result_head = solution.removeNthFromEnd(head, n)
    result = print_linked_list(result_head)
    print(f'Test case {i+1}: {result == expected_output}')",,0,0
20,"def isValid(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
    return not stack


# Test cases
inputs = [
    ""()"",
    ""()[]{}"",
    ""(]"",
    ""([)]"",
    ""{[]}""
]
outputs = [
    True,
    True,
    False,
    False,
    True
]

# Run tests and print results
for i in range(len(inputs)):
    result = isValid(inputs[i])
    print(result == outputs[i])","True
True
True
True
True",5,0
21,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(0)
        tail = dummy

        while l1 and l2:
            if l1.val < l2.val:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next

        if l1:
            tail.next = l1
        elif l2:
            tail.next = l2

        return dummy.next

def print_linked_list(head):
    result = []
    current = head
    while current:
        result.append(current.val)
        current = current.next
    return result

test_cases = [
    ([1, 2, 4], [1, 3, 4], [1, 1, 2, 3, 4, 4]),
    ([], [], []),
    ([], [0], [0]),
]

solution = Solution()

for i, (l1_list, l2_list, expected_output) in enumerate(test_cases):
    l1 = ListNode(0)
    current = l1
    for val in l1_list:
        current.next = ListNode(val)
        current = current.next
    l1 = l1.next

    l2 = ListNode(0)
    current = l2
    for val in l2_list:
        current.next = ListNode(val)
        current = current.next
    l2 = l2.next

    merged_list = solution.mergeTwoLists(l1, l2)
    output = print_linked_list(merged_list)

    print(f""Test Case {i+1}: {output == expected_output}"")",,0,0
22,"def generateParenthesis(n):
    result = []
    def backtrack(s, left, right):
        if len(s) == 2 * n:
            result.append(s)
            return
        if left < n:
            backtrack(s + '(', left + 1, right)
        if right < left:
            backtrack(s + ')', left, right + 1)
    backtrack('', 0, 0)
    return result


# Test cases
inputs = [3, 1]
outputs = [[""((()))"",""(()())"",""(())()"",""()(())"",""()()()""], [""()""]]

for i in range(len(inputs)):
    print(generateParenthesis(inputs[i]) == outputs[i])","True
True",2,0
23,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeKLists(lists):
    if not lists:
        return None

    while len(lists) > 1:
        mergedLists = []
        for i in range(0, len(lists), 2):
            l1 = lists[i]
            l2 = lists[i + 1] if i + 1 < len(lists) else None
            mergedLists.append(mergeTwoLists(l1, l2))
        lists = mergedLists
    return lists[0]

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    tail = dummy

    while l1 and l2:
        if l1.val < l2.val:
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next

    if l1:
        tail.next = l1
    if l2:
        tail.next = l2

    return dummy.next

def createLinkedList(values):
    if not values:
        return None
    head = ListNode(values[0])
    current = head
    for i in range(1, len(values)):
        current.next = ListNode(values[i])
        current = current.next
    return head

def linkedListToValues(head):
    values = []
    while head:
        values.append(head.val)
        head = head.next
    return values

# Test cases
inputs = [
    [[1,4,5],[1,3,4],[2,6]],
    [],
    [[]]
]
outputs = [
    [1,1,2,3,4,4,5,6],
    [],
    []
]

for i in range(len(inputs)):
    input_linked_lists = [createLinkedList(sublist) for sublist in inputs[i]]
    merged_list = mergeKLists(input_linked_lists)
    output_values = linkedListToValues(merged_list)
    print(output_values == outputs[i])","True
True
True",3,0
24,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        dummy = ListNode(0, head)
        prev, curr = dummy, head

        while curr and curr.next:
            # Save pointers
            second = curr.next
            nxt = curr.next.next

            # Swap nodes
            second.next = curr
            curr.next = nxt
            prev.next = second

            # Move pointers
            prev = curr
            curr = nxt

        return dummy.next


def print_linked_list(head):
    result = []
    current = head
    while current:
        result.append(current.val)
        current = current.next
    return result

# Test cases
head1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4))))
output1 = [2, 1, 4, 3]
print(f""Input 1: True"" if print_linked_list(Solution().swapPairs(head1)) == output1 else ""Input 1: False"")

head2 = None
output2 = []
print(f""Input 2: True"" if print_linked_list(Solution().swapPairs(head2)) == output2 else ""Input 2: False"")

head3 = ListNode(1)
output3 = [1]
print(f""Input 3: True"" if print_linked_list(Solution().swapPairs(head3)) == output3 else ""Input 3: False"")",,0,0
25,429 Resource has been exhausted (e.g. check quota).,ERROR,ERROR,ERROR
10,"import re

def isMatch(s: str, p: str) -> bool:
    return re.fullmatch(p, s) is not None

s1 = ""aa""
p1 = ""a""
output1 = isMatch(s1, p1)
expected_output1 = False
print(f""Test 1: {output1 == expected_output1}"")

s2 = ""aa""
p2 = ""a*""
output2 = isMatch(s2, p2)
expected_output2 = True
print(f""Test 2: {output2 == expected_output2}"")

s3 = ""ab""
p3 = "".*""
output3 = isMatch(s3, p3)
expected_output3 = True
print(f""Test 3: {output3 == expected_output3}"")","Test 1: True
Test 2: True
Test 3: True",3,0
11,429 Resource has been exhausted (e.g. check quota).,ERROR,ERROR,ERROR
11,429 Resource has been exhausted (e.g. check quota).,ERROR,ERROR,ERROR
11,429 Resource has been exhausted (e.g. check quota).,ERROR,ERROR,ERROR
2,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1, l2):
        dummy = ListNode(0)
        curr = dummy
        carry = 0

        while l1 or l2 or carry:
            val1 = l1.val if l1 else 0
            val2 = l2.val if l2 else 0

            total = val1 + val2 + carry
            carry = total // 10
            curr.next = ListNode(total % 10)

            curr = curr.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None

        return dummy.next

def print_linked_list(head):
    result = []
    while head:
        result.append(head.val)
        head = head.next
    return result

# Test cases
test_cases = [
    ([2, 4, 3], [5, 6, 4], [7, 0, 8]),
    ([0], [0], [0]),
    ([9, 9, 9, 9, 9, 9, 9], [9, 9, 9, 9], [8, 9, 9, 9, 0, 0, 0, 1]),
]

solution = Solution()
for i, (l1, l2, expected) in enumerate(test_cases):
    l1 = ListNode(l1[0])
    curr = l1
    for val in l1[1:]:
        curr.next = ListNode(val)
        curr = curr.next

    l2 = ListNode(l2[0])
    curr = l2
    for val in l2[1:]:
        curr.next = ListNode(val)
        curr = curr.next

    result = solution.addTwoNumbers(l1, l2)
    result_list = print_linked_list(result)
    print(f'Test Case {i+1}: {result_list == expected}')",,0,0
3,"def length_of_longest_substring(s: str) -> int:
    char_set = set()
    l = 0
    max_length = 0
    for r in range(len(s)):
        while s[r] in char_set:
            char_set.remove(s[l])
            l += 1
        char_set.add(s[r])
        max_length = max(max_length, r - l + 1)
    return max_length


input_1 = ""abcabcbb""
output_1 = 3
input_2 = ""bbbbb""
output_2 = 1
input_3 = ""pwwkew""
output_3 = 3
input_4 = """"
output_4 = 0

print(length_of_longest_substring(input_1) == output_1)
print(length_of_longest_substring(input_2) == output_2)
print(length_of_longest_substring(input_3) == output_3)
print(length_of_longest_substring(input_4) == output_4)","True
True
True
True",4,0
4,"class Solution:
    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -> float:
        m, n = len(nums1), len(nums2)
        if m > n:
            nums1, nums2, m, n = nums2, nums1, n, m
        if n == 0:
            raise ValueError

        imin, imax, half_len = 0, m, (m + n + 1) // 2
        while imin <= imax:
            i = (imin + imax) // 2
            j = half_len - i
            if i < m and nums1[i] < nums2[j-1]:
                # i is too small, increase it
                imin = i + 1
            elif i > 0 and nums1[i-1] > nums2[j]:
                # i is too big, decrease it
                imax = i - 1
            else:
                # i is perfect

                if i == 0: max_left = nums2[j-1]
                elif j == 0: max_left = nums1[i-1]
                else: max_left = max(nums1[i-1], nums2[j-1])

                if (m + n) % 2 == 1:
                    return max_left

                if i == m: min_right = nums2[j]
                elif j == n: min_right = nums1[i]
                else: min_right = min(nums1[i], nums2[j])

                return (max_left + min_right) / 2.0

test_cases = [
    (([1, 3], [2]), 2.00000),
    (([1, 2], [3, 4]), 2.50000),
    (([0, 0], [0, 0]), 0.00000),
    (([], [1]), 1.00000),
    (([2], []), 2.00000),
]

s = Solution()
for i, (input_args, expected_output) in enumerate(test_cases):
    result = s.findMedianSortedArrays(*input_args)
    print(f""Test Case {i+1}: {'True' if result == expected_output else 'False'}"")","Test Case 1: True
Test Case 2: True
Test Case 3: True
Test Case 4: True
Test Case 5: True",5,0
5,"def longestPalindrome(s: str) -> str:
    n = len(s)
    if n < 2:
        return s
    dp = [[False] * n for _ in range(n)]
    for i in range(n):
        dp[i][i] = True
    max_len = 1
    start = 0
    for l in range(2, n + 1):
        for i in range(n - l + 1):
            j = i + l - 1
            if l == 2:
                dp[i][j] = (s[i] == s[j])
            else:
                dp[i][j] = (s[i] == s[j] and dp[i + 1][j - 1])
            if dp[i][j] and l > max_len:
                max_len = l
                start = i
    return s[start:start + max_len]


# Test cases
input1 = ""babad""
output1 = ""bab""
input2 = ""cbbd""
output2 = ""bb""
input3 = ""a""
output3 = ""a""

print(longestPalindrome(input1) == output1)
print(longestPalindrome(input2) == output2)
print(longestPalindrome(input3) == output3)","True
True
True",3,0
6,"def convert(s, numRows):
    if numRows == 1 or numRows >= len(s):
        return s
    rows = [''] * numRows
    row, step = 0, 1
    for char in s:
        rows[row] += char
        if row == numRows - 1:
            step = -1
        elif row == 0:
            step = 1
        row += step
    return ''.join(rows)


# Test cases
input1 = ""PAYPALISHIRING""
output1 = ""PAHNAPLSIIGYIR""
input2 = ""PAYPALISHIRING""
output2 = ""PINALSIGYAHRPI""
input3 = ""A""
output3 = ""A""

print(convert(input1, 3) == output1)
print(convert(input2, 4) == output2)
print(convert(input3, 1) == output3)","True
True
True",3,0
7,"def reverse_integer(x):
    sign = 1 if x >= 0 else -1
    x = abs(x)
    reversed_x = 0
    while x > 0:
        digit = x % 10
        reversed_x = reversed_x * 10 + digit
        x //= 10
    reversed_x = sign * reversed_x
    if reversed_x < -2**31 or reversed_x > 2**31 - 1:
        return 0
    return reversed_x

# Test cases
inputs = [123, -123, 120, 0]
outputs = [321, -321, 21, 0]

for i in range(len(inputs)):
    result = reverse_integer(inputs[i])
    print(result == outputs[i])","True
True
True
True",4,0
8,"def myAtoi(s):
    s = s.strip()
    if not s:
        return 0

    sign = 1
    if s[0] == '-':
        sign = -1
        s = s[1:]
    elif s[0] == '+':
        s = s[1:]

    result = 0
    for c in s:
        if not c.isdigit():
            break
        result = result * 10 + int(c)

    result *= sign
    result = max(min(result, 2**31 - 1), -2**31)
    return result


# Test cases
inputs = [
    ""42"",
    ""   -42"",
    ""4193 with words"",
    ""words and 987"",
    ""-91283472332""
]
outputs = [
    42,
    -42,
    4193,
    0,
    -2147483648
]

for i in range(len(inputs)):
    output = myAtoi(inputs[i])
    print(output == outputs[i])","True
True
True
True
True",5,0
9,"def isPalindrome(x):
    if x < 0:
        return False
    div = 1
    while x // div >= 10:
        div *= 10
    while x != 0:
        left = x // div
        right = x % 10
        if left != right:
            return False
        x = (x % div) // 10
        div //= 100
    return True

print(isPalindrome(121) == True)
print(isPalindrome(-121) == False)
print(isPalindrome(10) == False)","True
True
True",3,0
10,"import re

def is_match(s, p):
    return bool(re.fullmatch(p, s))

s1 = ""aa""
p1 = ""a""
output1 = is_match(s1, p1)
expected_output1 = False
print(output1 == expected_output1)

s2 = ""aa""
p2 = ""a*""
output2 = is_match(s2, p2)
expected_output2 = True
print(output2 == expected_output2)

s3 = ""ab""
p3 = "".*""
output3 = is_match(s3, p3)
expected_output3 = True
print(output3 == expected_output3)

s4 = ""aab""
p4 = ""c*a*b""
output4 = is_match(s4, p4)
expected_output4 = True
print(output4 == expected_output4)

s5 = ""mississippi""
p5 = ""mis*is*p*.""
output5 = is_match(s5, p5)
expected_output5 = False
print(output5 == expected_output5)","True
True
True
True
True",5,0
11,"def maxArea(height):
    l, r = 0, len(height) - 1
    max_area = 0
    while l < r:
        max_area = max(max_area, min(height[l], height[r]) * (r - l))
        if height[l] < height[r]:
            l += 1
        else:
            r -= 1
    return max_area

input_1 = [1,8,6,2,5,4,8,3,7]
output_1 = 49
input_2 = [1,1]
output_2 = 1
input_3 = [4,3,2,1,4]
output_3 = 16

print(f""Input 1: {input_1}, Output: {output_1}, Result: {maxArea(input_1) == output_1}"")
print(f""Input 2: {input_2}, Output: {output_2}, Result: {maxArea(input_2) == output_2}"")
print(f""Input 3: {input_3}, Output: {output_3}, Result: {maxArea(input_3) == output_3}"")","Input 1: [1, 8, 6, 2, 5, 4, 8, 3, 7], Output: 49, Result: True
Input 2: [1, 1], Output: 1, Result: True
Input 3: [4, 3, 2, 1, 4], Output: 16, Result: True",3,0
12,"def intToRoman(num: int) -> str:
    symbol_map = {1: 'I', 4: 'IV', 5: 'V', 9: 'IX', 10: 'X', 40: 'XL', 50: 'L', 90: 'XC', 100: 'C', 400: 'XD', 500: 'D', 900: 'CM', 1000: 'M'}
    integers = list(symbol_map.keys())
    symbols = list(symbol_map.values())

    i = 12
    result = ''

    while num != 0:
        if integers[i] <= num:
            result += symbols[i]
            num -= integers[i]
        else:
            i -= 1

    return result

# Test cases
input_values = [3, 4, 9, 58, 1994]
output_values = [""III"", ""IV"", ""IX"", ""LVIII"", ""MCMXCIV""]

for i in range(len(input_values)):
    print(intToRoman(input_values[i]) == output_values[i])","True
True
True
True
True",5,0
13,"def roman_to_integer(s):
    roman_map = {
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000
    }
    n = len(s)
    num = roman_map[s[n - 1]]
    for i in range(n - 2, -1, -1):
        if roman_map[s[i]] >= roman_map[s[i + 1]]:
            num += roman_map[s[i]]
        else:
            num -= roman_map[s[i]]
    return num


input_1 = ""III""
output_1 = 3
input_2 = ""IV""
output_2 = 4
input_3 = ""IX""
output_3 = 9
input_4 = ""LVIII""
output_4 = 58
input_5 = ""MCMXCIV""
output_5 = 1994

print(roman_to_integer(input_1) == output_1)
print(roman_to_integer(input_2) == output_2)
print(roman_to_integer(input_3) == output_3)
print(roman_to_integer(input_4) == output_4)
print(roman_to_integer(input_5) == output_5)","True
True
True
True
True",5,0
14,"def longestCommonPrefix(strs):
    if not strs:
        return """"
    shortest = min(strs, key=len)
    for i, char in enumerate(shortest):
        for other in strs:
            if other[i] != char:
                return shortest[:i]
    return shortest


input_1 = [""flower"", ""flow"", ""flight""]
output_1 = ""fl""
input_2 = [""dog"", ""racecar"", ""car""]
output_2 = """"

print(longestCommonPrefix(input_1) == output_1)
print(longestCommonPrefix(input_2) == output_2)","True
True",2,0
15,"def three_sum(nums):
    res = []
    nums.sort()
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        l, r = i + 1, len(nums) - 1
        while l < r:
            s = nums[i] + nums[l] + nums[r]
            if s < 0:
                l += 1
            elif s > 0:
                r -= 1
            else:
                res.append([nums[i], nums[l], nums[r]])
                while l < r and nums[l] == nums[l + 1]:
                    l += 1
                while l < r and nums[r] == nums[r - 1]:
                    r -= 1
                l += 1
                r -= 1
    return res


input_value_1 = [-1, 0, 1, 2, -1, -4]
output_value_1 = [[-1, -1, 2], [-1, 0, 1]]
input_value_2 = []
output_value_2 = []
input_value_3 = [0]
output_value_3 = []

print(three_sum(input_value_1) == output_value_1)
print(three_sum(input_value_2) == output_value_2)
print(three_sum(input_value_3) == output_value_3)","True
True
True",3,0
16,"def three_sum_closest(nums, target):
    nums.sort()
    closest_sum = float('inf')

    for i in range(len(nums) - 2):
        left = i + 1
        right = len(nums) - 1

        while left < right:
            current_sum = nums[i] + nums[left] + nums[right]

            if current_sum == target:
                return target

            if abs(current_sum - target) < abs(closest_sum - target):
                closest_sum = current_sum

            if current_sum < target:
                left += 1
            else:
                right -= 1

    return closest_sum


# Test cases
input_1 = [-1, 2, 1, -4]
target_1 = 1
output_1 = 2

input_2 = None  # No second example provided
target_2 = None
output_2 = None

input_3 = None  # No third example provided
target_3 = None
output_3 = None

print(f""Input 1: {three_sum_closest(input_1, target_1) == output_1}"")

# Cannot test input 2 and 3 as they are not provided",Input 1: True,1,0
17,"def letterCombinations(digits):
    if not digits:
        return []

    mapping = {
        '2': 'abc',
        '3': 'def',
        '4': 'ghi',
        '5': 'jkl',
        '6': 'mno',
        '7': 'pqrs',
        '8': 'tuv',
        '9': 'wxyz'
    }

    result = ['']
    for digit in digits:
        temp = []
        for letter in mapping[digit]:
            for combination in result:
                temp.append(combination + letter)
        result = temp
    return result


# Test cases
digits1 = ""23""
output1 = [""ad"",""ae"",""af"",""bd"",""be"",""bf"",""cd"",""ce"",""cf""]
digits2 = """"
output2 = []
digits3 = ""2""
output3 = [""a"",""b"",""c""]

print(letterCombinations(digits1) == output1)  
print(letterCombinations(digits2) == output2)  
print(letterCombinations(digits3) == output3)  ","False
True
True",2,1
18,"from typing import List
def four_sum(nums: List[int], target: int) -> List[List[int]]:
    nums.sort()
    result = []
    n = len(nums)
    for i in range(n - 3):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        for j in range(i + 1, n - 2):
            if j > i + 1 and nums[j] == nums[j - 1]:
                continue
            left = j + 1
            right = n - 1
            while left < right:
                total = nums[i] + nums[j] + nums[left] + nums[right]
                if total == target:
                    result.append([nums[i], nums[j], nums[left], nums[right]])
                    left += 1
                    right -= 1
                    while left < right and nums[left] == nums[left - 1]:
                        left += 1
                    while left < right and nums[right] == nums[right + 1]:
                        right -= 1
                elif total < target:
                    left += 1
                else:
                    right -= 1
    return result


nums1 = [1, 0, -1, 0, -2, 2]
target1 = 0
output1 = [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
print(f""Input 1: {nums1} Target: {target1} - Output: {four_sum(nums1, target1) == output1}"")

nums2 = []
target2 = 0
output2 = []
print(f""Input 2: {nums2} Target: {target2} - Output: {four_sum(nums2, target2) == output2}"")","Input 1: [1, 0, -1, 0, -2, 2] Target: 0 - Output: True
Input 2: [] Target: 0 - Output: True",2,0
19,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def remove_nth_from_end(head, n):
    dummy = ListNode(0, head)
    slow = dummy
    fast = dummy
    for i in range(n + 1):
        fast = fast.next
    while fast:
        slow = slow.next
        fast = fast.next
    slow.next = slow.next.next
    return dummy.next

def create_linked_list(values):
    if not values:
        return None
    head = ListNode(values[0])
    current = head
    for val in values[1:]:
        current.next = ListNode(val)
        current = current.next
    return head

def linked_list_to_list(head):
    result = []
    current = head
    while current:
        result.append(current.val)
        current = current.next
    return result

# Test cases
inputs = [
    ([1, 2, 3, 4, 5], 2),
    ([1], 1),
    ([1, 2], 1),
]
outputs = [
    [1, 2, 3, 5],
    [],
    [1],
]

for i in range(len(inputs)):
    head = create_linked_list(inputs[i][0])
    n = inputs[i][1]
    result = remove_nth_from_end(head, n)
    result_list = linked_list_to_list(result)
    print(result_list == outputs[i])","True
True
True",3,0
20,"def isValid(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
    return not stack


input_1 = ""()""
output_1 = True
input_2 = ""()[]{}""
output_2 = True
input_3 = ""(]""
output_3 = False

print(isValid(input_1) == output_1)
print(isValid(input_2) == output_2)
print(isValid(input_3) == output_3)","True
True
True",3,0
21,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(0)
        curr = dummy

        while l1 and l2:
            if l1.val <= l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next

        if l1:
            curr.next = l1
        else:
            curr.next = l2

        return dummy.next

def print_linked_list(head):
    result = []
    current = head
    while current:
        result.append(current.val)
        current = current.next
    return result

# Test cases
test_cases = [
    ([1,2,4], [1,3,4], [1,1,2,3,4,4]),
    ([], [], []),
    ([], [0], [0])
]

solution = Solution()

for i, (l1_list, l2_list, expected_output) in enumerate(test_cases):
    # Create linked lists from input lists
    l1 = ListNode(0)
    current = l1
    for val in l1_list:
        current.next = ListNode(val)
        current = current.next
    l1 = l1.next

    l2 = ListNode(0)
    current = l2
    for val in l2_list:
        current.next = ListNode(val)
        current = current.next
    l2 = l2.next

    # Run the solution and compare the output
    merged_list = solution.mergeTwoLists(l1, l2)
    output = print_linked_list(merged_list)
    is_correct = output == expected_output
    print(f""Test case {i+1}: {is_correct}"")",,0,0
22,"def generateParenthesis(n):
    result = []
    def backtrack(s, left, right):
        if len(s) == 2 * n:
            result.append(s)
            return
        if left < n:
            backtrack(s + '(', left + 1, right)
        if right < left:
            backtrack(s + ')', left, right + 1)
    backtrack('', 0, 0)
    return result


# Test cases
inputs = [3, 1]
outputs = [[""((()))"",""(()())"",""(())()"",""()(())"",""()()()""], [""()""]]

for i in range(len(inputs)):
    print(generateParenthesis(inputs[i]) == outputs[i])","True
True",2,0
23,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeKLists(self, lists):
        if not lists:
            return None

        while len(lists) > 1:
            mergedLists = []
            for i in range(0, len(lists), 2):
                l1 = lists[i]
                l2 = lists[i + 1] if (i + 1) < len(lists) else None
                mergedLists.append(self.mergeTwoLists(l1, l2))
            lists = mergedLists
        return lists[0]

    def mergeTwoLists(self, l1, l2):
        dummy = ListNode()
        tail = dummy

        while l1 and l2:
            if l1.val < l2.val:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next

        if l1:
            tail.next = l1
        elif l2:
            tail.next = l2

        return dummy.next

def printLinkedList(head):
    result = []
    current = head
    while current:
        result.append(current.val)
        current = current.next
    return result

# Example usage and verification
lists1 = [[1,4,5],[1,3,4],[2,6]]
lists2 = []
lists3 = [[]]

solution = Solution()

# Test Case 1
output1 = solution.mergeKLists(createLinkedList(lists1))
print(printLinkedList(output1) == [1,1,2,3,4,4,5,6])

# Test Case 2
output2 = solution.mergeKLists(createLinkedList(lists2))
print(printLinkedList(output2) == [])

# Test Case 3
output3 = solution.mergeKLists(createLinkedList(lists3))
print(printLinkedList(output3) == [])",,0,0
24,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        dummy = ListNode(0, head)
        prev, curr = dummy, head

        while curr and curr.next:
            # Save pointers
            nxtPair = curr.next.next
            second = curr.next

            # Reverse this pair
            second.next = curr
            curr.next = nxtPair
            prev.next = second

            # Update pointers
            prev = curr
            curr = nxtPair

        return dummy.next


def print_linked_list(head):
    current = head
    values = []
    while current:
        values.append(current.val)
        current = current.next
    return values

# Test cases
test_cases = [
    ([1, 2, 3, 4], [2, 1, 4, 3]),
    ([], []),
    ([1], [1])
]

for i, (input_list, expected_output) in enumerate(test_cases):
    head = ListNode(0)
    current = head
    for val in input_list:
        current.next = ListNode(val)
        current = current.next
    head = head.next

    solution = Solution()
    result_head = solution.swapPairs(head)
    result = print_linked_list(result_head)
    print(f""Test case {i+1}: {result == expected_output}"")",,0,0
25,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_k_group(head, k):
    dummy = ListNode(0, head)
    group_prev = dummy

    while True:
        kth = get_kth(group_prev, k)
        if not kth:
            break
        group_next = kth.next

        # reverse group
        prev, curr = kth.next, group_prev.next
        while curr != group_next:
            tmp = curr.next
            curr.next = prev
            prev = curr
            curr = tmp

        # update pointers
        tmp = group_prev.next
        group_prev.next = kth
        group_prev = tmp

    return dummy.next

def get_kth(curr, k):
    while curr and k > 0:
        curr = curr.next
        k -= 1
    return curr

def create_linked_list(values):
    if not values:
        return None
    head = ListNode(values[0])
    curr = head
    for val in values[1:]:
        curr.next = ListNode(val)
        curr = curr.next
    return head

def linked_list_to_list(head):
    values = []
    curr = head
    while curr:
        values.append(curr.val)
        curr = curr.next
    return values

# Test cases
inputs = [([1,2,3,4,5], 2), ([1,2,3,4,5], 3), ([1,2,3,4,5], 1), ([1], 1)]
outputs = [[2,1,4,3,5], [3,2,1,4,5], [1,2,3,4,5], [1]]

for i in range(len(inputs)):
    head = create_linked_list(inputs[i][0])
    k = inputs[i][1]
    result = reverse_k_group(head, k)
    output = linked_list_to_list(result)
    print(output == outputs[i])","True
True
True
True",4,0
26,"def removeDuplicates(nums):
    if len(nums) == 0:
        return 0
    i = 0
    for j in range(1, len(nums)):
        if nums[j] != nums[i]:
            i += 1
            nums[i] = nums[j]
    return i + 1


def test_remove_duplicates(nums, expected_output):
    result = removeDuplicates(nums)
    nums = nums[:result]
    return nums == expected_output

# Test cases
input1 = [1, 1, 2]
output1 = [1, 2]
print(f""Input 1: {input1}, Output 1: {test_remove_duplicates(input1, output1)}"")

input2 = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]
output2 = [0, 1, 2, 3, 4]
print(f""Input 2: {input2}, Output 2: {test_remove_duplicates(input2, output2)}"")","Input 1: [1, 1, 2], Output 1: True
Input 2: [0, 0, 1, 1, 1, 2, 2, 3, 3, 4], Output 2: True",2,0
